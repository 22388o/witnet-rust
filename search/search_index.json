{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Witnet-rust \u00b6 Witnet-rust is an open-source implementation of the Witnet protocol written in Rust. The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central to incentivizing the network players to abide by the protocol and make them liable for any misbehavior. Active network participants will earn wit tokens for fulfilling the data retrieval, attestation and delivery tasks coming from different smart contract platforms such as Ethereum and RChain. Witnet-rust is the first open-source implementation of the Witnet protocol and leverages the Rust programming language to achieve utmost speed, memory safety and fearless concurrency without compromising on performance. Tip See \" Why Rust? \" for a more technical overview on why we chose Rust. Get started \u00b6 Installation \u00b6 Witnet-rust is an open-source native app providing \"full node\" functionality of the Witnet Decentralized Oracle Network protocol. It is available under the GNU General Public License v3.0 . You may refer to the installation guide in order to install the app together with its dependencies. Roadmap \u00b6 Witnet-rust is an ambitious effort in its early days. We are currently working towards launching our first testnet. As you can guess from our datailed roadmap and GitHub issues , there are still a lot of missing features (and a whole lot more that would be nice to have yet not critical for our testnet launch). Contributing \u00b6 See the contributing guide to get more information on how to contribute to Rust-witnet development, and the roadmap to find out what features are coming soon.","title":"Home"},{"location":"#witnet-rust","text":"Witnet-rust is an open-source implementation of the Witnet protocol written in Rust. The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central to incentivizing the network players to abide by the protocol and make them liable for any misbehavior. Active network participants will earn wit tokens for fulfilling the data retrieval, attestation and delivery tasks coming from different smart contract platforms such as Ethereum and RChain. Witnet-rust is the first open-source implementation of the Witnet protocol and leverages the Rust programming language to achieve utmost speed, memory safety and fearless concurrency without compromising on performance. Tip See \" Why Rust? \" for a more technical overview on why we chose Rust.","title":"Witnet-rust"},{"location":"#get-started","text":"","title":"Get started"},{"location":"#installation","text":"Witnet-rust is an open-source native app providing \"full node\" functionality of the Witnet Decentralized Oracle Network protocol. It is available under the GNU General Public License v3.0 . You may refer to the installation guide in order to install the app together with its dependencies.","title":"Installation"},{"location":"#roadmap","text":"Witnet-rust is an ambitious effort in its early days. We are currently working towards launching our first testnet. As you can guess from our datailed roadmap and GitHub issues , there are still a lot of missing features (and a whole lot more that would be nice to have yet not critical for our testnet launch).","title":"Roadmap"},{"location":"#contributing","text":"See the contributing guide to get more information on how to contribute to Rust-witnet development, and the roadmap to find out what features are coming soon.","title":"Contributing"},{"location":"contributing/","text":"Contributing to Witnet-rust \u00b6 Thank you for being interested in contributing to Witnet! The following is a set of guidelines and helpful pointers for contributing to Witnet The keyword here is guidelines, not rules. As such, use your best judgement and feel free to propose changes to even this document. Code of conduct \u00b6 Everyone participating in this project is governed by the Witnet Code of Conduct . By participating, you are expected to uphold this code as well. I just have a question \u00b6 Please don't file an issue with questions. It's easier for you and for us if you go directly to our Gitter chatroom , since it will keep our repositories clean and you will get a faster response. How can I contribute? \u00b6 Find an area you can help with and do it. Open source is about collaboration and open participation. Try to make your code look like what already exists and submit a pull request. The list of issues is a good place to start, especially the ones tagged as \"good first issue\" or \"help wanted\" (but don't let that stop you from looking at others). If you're looking for additional ideas, the code includes TODO comments for minor to major improvements. Grep is your friend. Additional tests are rewarded with an immense amount of positive karma. More documentation or updates/fixes to existing documentation are also very welcome. However, if submitting a PR consisting of documentation changes only, please try to ensure that the change is significantly more substantial than one or two lines. For example, working through an install document and making changes and updates throughout as you find issues is worth a PR. For typos and other small changes, either contact one of the developers, or if you think it's a significant enough error to cause problems for other users, please feel free to open an issue. Reporting bugs \u00b6 This section guides you through submitting a bug report. This helps contributors and maintainers understand your report, reproduce the behavior, and in turn squash the bug. Before submitting a bug report, please make sure that you've searched through the issues and that there isn't already an issue describing the same issue you are having. How do I submit a good bug report? \u00b6 Bugs are tracked as GitHub issues . Explain the problem and include additional details to help maintainers reproduce the problem: Use a clear and descriptive title for the issue to identify the problem. Describe the exact steps which reproduce the problem in as many details as possible. Provide specific examples to demonstrate the steps. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use Markdown code blocks. Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior. Explain which behavior you expected to see instead and why. Post a screenshot or a dump of the developer console If the problem wasn't triggered by a specific action, describe what you were doing before the problem happened and share more information using the guidelines below. Provide more context by answering these questions: Did the problem start happening recently (e.g. after updating to a new version) or was this always a problem? If the problem started happening recently, can you reproduce the problem in an older version of Witnet-rust? What's the most recent version in which the problem doesn't happen? Can you reliably reproduce the issue? If not, provide details about how often the problem happens and under which conditions it normally happens. Include details about your configuration and environment: Which version of rustc are you using? You can get the exact version by running rustc --version --verbose in your terminal. What's your operating system and version? Suggesting enhancements \u00b6 This section guides you through submitting an enhancement suggestion, including completely new features and minor improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion. Before creating enhancement suggestions, please double check that there is not already an existing feature suggestion for your feature, as you might find out that you don't need to create one. When you are creating an enhancement suggestion, please include as many details as possible. How Do I Submit A Good Enhancement Suggestion? \u00b6 Enhancement suggestions are tracked as GitHub issues. Create an issue on that repository and provide the following information: Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Provide specific examples to demonstrate the steps. Include copy/pasteable snippets which you use in those examples, as Markdown code blocks. Describe the current behavior and explain which behavior you expected to see instead and why. Explain why this enhancement would be useful to most users and isn't something that can or should be implemented as a community package. Your First Code Contribution \u00b6 Unsure where to begin contributing? You can start by looking through these good first issue issues: Good first issue - issues which should only require a few lines of code, and a test or two. Copyright \u00b6 These guidelines are inspired by: AragonJS Contributing Guidelines , published under the Creative Commons Zero v1.0 Universal License . Grin Contributing Guide , published under the Apache License 2.0 .","title":"Contributing to Witnet-rust"},{"location":"contributing/#contributing-to-witnet-rust","text":"Thank you for being interested in contributing to Witnet! The following is a set of guidelines and helpful pointers for contributing to Witnet The keyword here is guidelines, not rules. As such, use your best judgement and feel free to propose changes to even this document.","title":"Contributing to Witnet-rust"},{"location":"contributing/#code-of-conduct","text":"Everyone participating in this project is governed by the Witnet Code of Conduct . By participating, you are expected to uphold this code as well.","title":"Code of conduct"},{"location":"contributing/#i-just-have-a-question","text":"Please don't file an issue with questions. It's easier for you and for us if you go directly to our Gitter chatroom , since it will keep our repositories clean and you will get a faster response.","title":"I just have a question"},{"location":"contributing/#how-can-i-contribute","text":"Find an area you can help with and do it. Open source is about collaboration and open participation. Try to make your code look like what already exists and submit a pull request. The list of issues is a good place to start, especially the ones tagged as \"good first issue\" or \"help wanted\" (but don't let that stop you from looking at others). If you're looking for additional ideas, the code includes TODO comments for minor to major improvements. Grep is your friend. Additional tests are rewarded with an immense amount of positive karma. More documentation or updates/fixes to existing documentation are also very welcome. However, if submitting a PR consisting of documentation changes only, please try to ensure that the change is significantly more substantial than one or two lines. For example, working through an install document and making changes and updates throughout as you find issues is worth a PR. For typos and other small changes, either contact one of the developers, or if you think it's a significant enough error to cause problems for other users, please feel free to open an issue.","title":"How can I contribute?"},{"location":"contributing/#reporting-bugs","text":"This section guides you through submitting a bug report. This helps contributors and maintainers understand your report, reproduce the behavior, and in turn squash the bug. Before submitting a bug report, please make sure that you've searched through the issues and that there isn't already an issue describing the same issue you are having.","title":"Reporting bugs"},{"location":"contributing/#how-do-i-submit-a-good-bug-report","text":"Bugs are tracked as GitHub issues . Explain the problem and include additional details to help maintainers reproduce the problem: Use a clear and descriptive title for the issue to identify the problem. Describe the exact steps which reproduce the problem in as many details as possible. Provide specific examples to demonstrate the steps. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use Markdown code blocks. Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior. Explain which behavior you expected to see instead and why. Post a screenshot or a dump of the developer console If the problem wasn't triggered by a specific action, describe what you were doing before the problem happened and share more information using the guidelines below. Provide more context by answering these questions: Did the problem start happening recently (e.g. after updating to a new version) or was this always a problem? If the problem started happening recently, can you reproduce the problem in an older version of Witnet-rust? What's the most recent version in which the problem doesn't happen? Can you reliably reproduce the issue? If not, provide details about how often the problem happens and under which conditions it normally happens. Include details about your configuration and environment: Which version of rustc are you using? You can get the exact version by running rustc --version --verbose in your terminal. What's your operating system and version?","title":"How do I submit a good bug report?"},{"location":"contributing/#suggesting-enhancements","text":"This section guides you through submitting an enhancement suggestion, including completely new features and minor improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion. Before creating enhancement suggestions, please double check that there is not already an existing feature suggestion for your feature, as you might find out that you don't need to create one. When you are creating an enhancement suggestion, please include as many details as possible.","title":"Suggesting enhancements"},{"location":"contributing/#how-do-i-submit-a-good-enhancement-suggestion","text":"Enhancement suggestions are tracked as GitHub issues. Create an issue on that repository and provide the following information: Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Provide specific examples to demonstrate the steps. Include copy/pasteable snippets which you use in those examples, as Markdown code blocks. Describe the current behavior and explain which behavior you expected to see instead and why. Explain why this enhancement would be useful to most users and isn't something that can or should be implemented as a community package.","title":"How Do I Submit A Good Enhancement Suggestion?"},{"location":"contributing/#your-first-code-contribution","text":"Unsure where to begin contributing? You can start by looking through these good first issue issues: Good first issue - issues which should only require a few lines of code, and a test or two.","title":"Your First Code Contribution"},{"location":"contributing/#copyright","text":"These guidelines are inspired by: AragonJS Contributing Guidelines , published under the Creative Commons Zero v1.0 Universal License . Grin Contributing Guide , published under the Apache License 2.0 .","title":"Copyright"},{"location":"architecture/storage/","text":"Persistent Storage \u00b6 From the perspective of software architecture, persistent storage is one of the key elements to maintaining a distributed block chain. Its role is allowing nodes in the network to preserve important data structures that need to be kept over time for trustless validation of new chain objects. Namely, those structures are: The UTXO set Data requests Transactions Blocks Generic Storage Trait \u00b6 Witnet-rust features a generic Storage Rust trait ( storage.rs ) that exposes a key/value API with the elemental CRUD methods (create, read, update, delete) while abstracting away from specific storage backend implementations. 1 pub trait Storage < ConnData , Key , Value > { /** **/ } The meaning of the generic types is the following: Generic type Description ConnData Type of the data needed by the constructor for creating a connection to the storage backend. Key Type of the keys used to identify the records in the storage. Value Type of the values in the storage. As of PR #21 , Witnet-rust incorporates implementations for the following storage backends: rocks.rs : persists data into the local file system using the performant RocksDB engine. in_memory.rs : keeps data in a HashMap that lives in the memory heap. Warning In-memory storage is implemented only for the sake of testing the Storage trait. It is obviously not a viable persistence solution as data is totally wiped as soon as references to the storage go out of scope or the app dies. Instantiation \u00b6 All implementations of the Storage trait can be instantiated with the witnet_storage::storage::new() constructor, which must be used as a static method. Signature \u00b6 1 fn new ( connection_data : ConnData ) -> Result < Box < Self >> ; Tip Please note that the witnet_storage::storage::new() method wraps the return type into a Box . This is to ensure the value is allocated into the heap and to allow a reference to it (the Box itself) to outlive the constructor. Example \u00b6 1 2 3 use witnet_storage :: backends :: in_memory :: InMemoryStorage ; let storage : & InMemoryStorage = InMemoryStorage :: new (). unwrap (); Creating and updating records with the put() Method \u00b6 The witnet_storage::storage::put() method allows creating or replacing a value in the storage under a certain key. Signature \u00b6 1 fn put ( & mut self , key : Key , value : Value ) -> Result < () > ; Example \u00b6 1 2 3 4 // Put value \"bar\" into key \"foo\" storage . put ( b\"foo\" , b\"bar\" . to_vec ()) ? ; // Update value of \"foo\" to be \"beer\" storage . put ( b\"foo\" , b\"beer\" . to_vec ()) ? ; Getting records with the get() method \u00b6 The witnet_storage::storage::get() method allows reading the value in the storage under a certain key. Signature \u00b6 1 fn get ( & self , key : Key ) -> Result < Option < Value >> ; Example \u00b6 1 2 3 4 5 match storage . get ( b\"foo\" ) { Ok ( Some ( value )) => , // Found a value Ok ( None ) => , // The key didn't exist Err ( error ) => // Error while reading } Deleting records with the delete() method \u00b6 The witnet_storage::storage::delete() method allows deleting a record in the storage given its key. Signature \u00b6 1 fn delete ( & mut self , key : Key ) -> Result < () > ; Example \u00b6 1 storage . delete ( b\"foo\" ) ? ; RocksDB Storage Backend \u00b6 The RocksDB storage backend ( rocks.rs ) is one of the bundled storage backends in Witnet-rust. It implements all the methods of the Storage trait for the RocksStorage struct: 1 2 3 4 5 /// Data structure for the RocksDB storage whose only member is a /// rocksdb::DB object. pub struct RocksStorage { db : DB } The materialized implementation looks like this (function bodies and some lifetime annotations have been omitted for brevity): 1 2 3 4 5 6 7 8 9 10 11 12 // Implement the Storage generic trait for the RocksStorage storage // data structure. impl Storage <& str , & [ u8 ], Vec < u8 >> for RocksStorage { fn new ( path : & str ) -> Result < Box < Self >> ; fn put ( & mut self , key : & [ u8 ], value : Vec < u8 > ) -> Result < () > ; fn get ( & self , key : & [ u8 ]) -> Result < Option < Vec < u8 >>> ; fn delete ( & mut self , key : & [ u8 ]) -> Result < () > ; } These are the specific types for this implementation: Generic type Specific type ConnData &str Key &[u8] Value Vec<u8> The full source code of the Storage implementation for RocksStorage can be found at rocks.rs .","title":"Persistent Storage"},{"location":"architecture/storage/#persistent-storage","text":"From the perspective of software architecture, persistent storage is one of the key elements to maintaining a distributed block chain. Its role is allowing nodes in the network to preserve important data structures that need to be kept over time for trustless validation of new chain objects. Namely, those structures are: The UTXO set Data requests Transactions Blocks","title":"Persistent Storage"},{"location":"architecture/storage/#generic-storage-trait","text":"Witnet-rust features a generic Storage Rust trait ( storage.rs ) that exposes a key/value API with the elemental CRUD methods (create, read, update, delete) while abstracting away from specific storage backend implementations. 1 pub trait Storage < ConnData , Key , Value > { /** **/ } The meaning of the generic types is the following: Generic type Description ConnData Type of the data needed by the constructor for creating a connection to the storage backend. Key Type of the keys used to identify the records in the storage. Value Type of the values in the storage. As of PR #21 , Witnet-rust incorporates implementations for the following storage backends: rocks.rs : persists data into the local file system using the performant RocksDB engine. in_memory.rs : keeps data in a HashMap that lives in the memory heap. Warning In-memory storage is implemented only for the sake of testing the Storage trait. It is obviously not a viable persistence solution as data is totally wiped as soon as references to the storage go out of scope or the app dies.","title":"Generic Storage Trait"},{"location":"architecture/storage/#instantiation","text":"All implementations of the Storage trait can be instantiated with the witnet_storage::storage::new() constructor, which must be used as a static method.","title":"Instantiation"},{"location":"architecture/storage/#signature","text":"1 fn new ( connection_data : ConnData ) -> Result < Box < Self >> ; Tip Please note that the witnet_storage::storage::new() method wraps the return type into a Box . This is to ensure the value is allocated into the heap and to allow a reference to it (the Box itself) to outlive the constructor.","title":"Signature"},{"location":"architecture/storage/#example","text":"1 2 3 use witnet_storage :: backends :: in_memory :: InMemoryStorage ; let storage : & InMemoryStorage = InMemoryStorage :: new (). unwrap ();","title":"Example"},{"location":"architecture/storage/#creating-and-updating-records-with-the-put-method","text":"The witnet_storage::storage::put() method allows creating or replacing a value in the storage under a certain key.","title":"Creating and updating records with the put() Method"},{"location":"architecture/storage/#signature_1","text":"1 fn put ( & mut self , key : Key , value : Value ) -> Result < () > ;","title":"Signature"},{"location":"architecture/storage/#example_1","text":"1 2 3 4 // Put value \"bar\" into key \"foo\" storage . put ( b\"foo\" , b\"bar\" . to_vec ()) ? ; // Update value of \"foo\" to be \"beer\" storage . put ( b\"foo\" , b\"beer\" . to_vec ()) ? ;","title":"Example"},{"location":"architecture/storage/#getting-records-with-the-get-method","text":"The witnet_storage::storage::get() method allows reading the value in the storage under a certain key.","title":"Getting records with the get() method"},{"location":"architecture/storage/#signature_2","text":"1 fn get ( & self , key : Key ) -> Result < Option < Value >> ;","title":"Signature"},{"location":"architecture/storage/#example_2","text":"1 2 3 4 5 match storage . get ( b\"foo\" ) { Ok ( Some ( value )) => , // Found a value Ok ( None ) => , // The key didn't exist Err ( error ) => // Error while reading }","title":"Example"},{"location":"architecture/storage/#deleting-records-with-the-delete-method","text":"The witnet_storage::storage::delete() method allows deleting a record in the storage given its key.","title":"Deleting records with the delete() method"},{"location":"architecture/storage/#signature_3","text":"1 fn delete ( & mut self , key : Key ) -> Result < () > ;","title":"Signature"},{"location":"architecture/storage/#example_3","text":"1 storage . delete ( b\"foo\" ) ? ;","title":"Example"},{"location":"architecture/storage/#rocksdb-storage-backend","text":"The RocksDB storage backend ( rocks.rs ) is one of the bundled storage backends in Witnet-rust. It implements all the methods of the Storage trait for the RocksStorage struct: 1 2 3 4 5 /// Data structure for the RocksDB storage whose only member is a /// rocksdb::DB object. pub struct RocksStorage { db : DB } The materialized implementation looks like this (function bodies and some lifetime annotations have been omitted for brevity): 1 2 3 4 5 6 7 8 9 10 11 12 // Implement the Storage generic trait for the RocksStorage storage // data structure. impl Storage <& str , & [ u8 ], Vec < u8 >> for RocksStorage { fn new ( path : & str ) -> Result < Box < Self >> ; fn put ( & mut self , key : & [ u8 ], value : Vec < u8 > ) -> Result < () > ; fn get ( & self , key : & [ u8 ]) -> Result < Option < Vec < u8 >>> ; fn delete ( & mut self , key : & [ u8 ]) -> Result < () > ; } These are the specific types for this implementation: Generic type Specific type ConnData &str Key &[u8] Value Vec<u8> The full source code of the Storage implementation for RocksStorage can be found at rocks.rs .","title":"RocksDB Storage Backend"},{"location":"get-started/what-is-witnet/","text":"What is Witnet \u00b6 The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. Wait, what? Ok, lets go one step at a time. Smart Contracts Are Not What You Think \u00b6 Over the last years, blockchain technology has promised to revolutionize business by allowing creation of \"smart contracts\" that, unlike paper contracts, are impossible to breach. Actually, those smart contracts are nothing more than small programs that can be run in a trustless manner. That is: once they are created, no one can stop them from doing exactly what they were created for. They just obey their own source code, and censorship is just impossible. This is a really powerful idea. If you can write a smart contract that: implements the logic of an agreement, and can execute the clauses of the contract on its own (like paying Alice or Bob depending on the outcome of some event), then you have a contract that is capable of enforcing itself and leaves no room for contestation. Boom . Blockchain Oracles, And Their Problem \u00b6 Given that smart contracts need to be completely deterministic 1 , they do not support input of data from non-deterministic sources such as APIs or websites. As a result, smart contracts are mostly isolated from the rest of the Internet, which dramatically reduces their transformative potential. At the end of the day, the output of a program does not depend solely on its source code, but also on the input data it operates upon. Of course, as the creator of a smart contract, you can create a method that allows you and only you to act as an \"oracle\" by introducing information from the outside at will. But you would be completely breaking the trustless nature of a smart contract. If trust is put in a single entity, there you have a single point of failure that can easily be hacked or corrupted. Smart contracts connected to the real world will not be completely trustless and will not release their full potential until we have ways to feed them information trustlessly. This is often called \"the oracle problem\" . The Solution: A Decentralized Oracle Network \u00b6 The Witnet protocol aims to create an overlay network that connects smart contracts to any online data source. Sport results, stock prices, weather forecasts or even other blockchains can be easily queried (preferably through APIs). The protocol describes a distributed network of peer nodes\u2014which we fondly call witnesses \u2014who earn Wit tokens as a reward for retrieving web data and reporting it directly to the smart contracts. The bottom line is that a considerable number of randomly selected, anonymous peers retrieving information from one or more sources can converge into a single truth about the data they retrieved if a majority of them are incentivized to report the retrieved data honestly and they apply a common consensus algorithm that resolves inconsistencies. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central to incentivizing the network players to abide by the protocol and make them liable for any misbehavior. Witnesses are also in charge of validating transactions in the network and bundling them into blocks that get appended to the blockchain periodically. The process by which witnesses retrieve, attest and deliver data in behalf of the smart contracts is in some way similar to mining in other blockchains. However, fulfilling these tasks and collecting the rewards is not that expensive in terms of computation. The protocol has been conceived to ensure utmost decentralization and fairnes, so each witness' weight in the network is not aligned to their computing power. Instead, the probability for every witness to be assigned tasks or mine new blocks is directly proportional to their past performance in terms of honesty: their reputation. Tip Of course, the so-called miners are not actual human beings sitting in front of a computer, fulfilling assignments coming from an Internet overlord that commands them to use their web browser to navigate to a certain website and take a snapshot or copy some text that they must report. Indeed, the miners are just computers running a software (Witnet-rust) that automatically receive and execute a series of tasks without the owner of the computer having to actively do anything else than installing it. 100% Truth, 0% Trust \u00b6 Data retrieved, attested and delivered using the Witnet protocol is reliable not because of authority but because it comes from anonymous nodes who are incentivized to remain honest and to compete for rewards. In addition, integrity of this data is guaranteed by a consensus algorithm that detects fraudsters, who are immediately punished. The progressive reputation protocol plays a central role in maintaining every participant active and honest by creating short, middle and long term incentives for them to abide by the protocol and not to tamper with the data they broker. Info Please note that Witnet's aim is not spotting fake data, but guaranteeing a 1:1 match between what is published online\u2014regardless of its truthness\u2014and the data that is eventually delivered the smart contracts. Who Is Behind Witnet \u00b6 Witnet is an open source project originally devised by Stampery , the leaders of blockchain-powered data certification. The protocol is now being developed by Witnet Foundation in collaboration with a community of independent contributors. Ever since Stampery was founded in 2014, they have been on a mission: replacing blind trust with mathematical proof. Witnet is the next step towards this goal. Stampery is backed by top venture capital funds and angel investors, including Tim Draper and Blockchain Capital. The Stampery team has also been involved in the development of Aragon , Trailbot , Mongoaudit and Loqui IM . Otherwise, the contracts could have totally different output values when executed across all the nodes maintaining the blockchain, therefore causing inconsistencies that would lead to breaking the network consensus. \u21a9","title":"What is Witnet"},{"location":"get-started/what-is-witnet/#what-is-witnet","text":"The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. Wait, what? Ok, lets go one step at a time.","title":"What is Witnet"},{"location":"get-started/what-is-witnet/#smart-contracts-are-not-what-you-think","text":"Over the last years, blockchain technology has promised to revolutionize business by allowing creation of \"smart contracts\" that, unlike paper contracts, are impossible to breach. Actually, those smart contracts are nothing more than small programs that can be run in a trustless manner. That is: once they are created, no one can stop them from doing exactly what they were created for. They just obey their own source code, and censorship is just impossible. This is a really powerful idea. If you can write a smart contract that: implements the logic of an agreement, and can execute the clauses of the contract on its own (like paying Alice or Bob depending on the outcome of some event), then you have a contract that is capable of enforcing itself and leaves no room for contestation. Boom .","title":"Smart Contracts Are Not What You Think"},{"location":"get-started/what-is-witnet/#blockchain-oracles-and-their-problem","text":"Given that smart contracts need to be completely deterministic 1 , they do not support input of data from non-deterministic sources such as APIs or websites. As a result, smart contracts are mostly isolated from the rest of the Internet, which dramatically reduces their transformative potential. At the end of the day, the output of a program does not depend solely on its source code, but also on the input data it operates upon. Of course, as the creator of a smart contract, you can create a method that allows you and only you to act as an \"oracle\" by introducing information from the outside at will. But you would be completely breaking the trustless nature of a smart contract. If trust is put in a single entity, there you have a single point of failure that can easily be hacked or corrupted. Smart contracts connected to the real world will not be completely trustless and will not release their full potential until we have ways to feed them information trustlessly. This is often called \"the oracle problem\" .","title":"Blockchain Oracles, And Their Problem"},{"location":"get-started/what-is-witnet/#the-solution-a-decentralized-oracle-network","text":"The Witnet protocol aims to create an overlay network that connects smart contracts to any online data source. Sport results, stock prices, weather forecasts or even other blockchains can be easily queried (preferably through APIs). The protocol describes a distributed network of peer nodes\u2014which we fondly call witnesses \u2014who earn Wit tokens as a reward for retrieving web data and reporting it directly to the smart contracts. The bottom line is that a considerable number of randomly selected, anonymous peers retrieving information from one or more sources can converge into a single truth about the data they retrieved if a majority of them are incentivized to report the retrieved data honestly and they apply a common consensus algorithm that resolves inconsistencies. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central to incentivizing the network players to abide by the protocol and make them liable for any misbehavior. Witnesses are also in charge of validating transactions in the network and bundling them into blocks that get appended to the blockchain periodically. The process by which witnesses retrieve, attest and deliver data in behalf of the smart contracts is in some way similar to mining in other blockchains. However, fulfilling these tasks and collecting the rewards is not that expensive in terms of computation. The protocol has been conceived to ensure utmost decentralization and fairnes, so each witness' weight in the network is not aligned to their computing power. Instead, the probability for every witness to be assigned tasks or mine new blocks is directly proportional to their past performance in terms of honesty: their reputation. Tip Of course, the so-called miners are not actual human beings sitting in front of a computer, fulfilling assignments coming from an Internet overlord that commands them to use their web browser to navigate to a certain website and take a snapshot or copy some text that they must report. Indeed, the miners are just computers running a software (Witnet-rust) that automatically receive and execute a series of tasks without the owner of the computer having to actively do anything else than installing it.","title":"The Solution: A Decentralized Oracle Network"},{"location":"get-started/what-is-witnet/#100-truth-0-trust","text":"Data retrieved, attested and delivered using the Witnet protocol is reliable not because of authority but because it comes from anonymous nodes who are incentivized to remain honest and to compete for rewards. In addition, integrity of this data is guaranteed by a consensus algorithm that detects fraudsters, who are immediately punished. The progressive reputation protocol plays a central role in maintaining every participant active and honest by creating short, middle and long term incentives for them to abide by the protocol and not to tamper with the data they broker. Info Please note that Witnet's aim is not spotting fake data, but guaranteeing a 1:1 match between what is published online\u2014regardless of its truthness\u2014and the data that is eventually delivered the smart contracts.","title":"100% Truth, 0% Trust"},{"location":"get-started/what-is-witnet/#who-is-behind-witnet","text":"Witnet is an open source project originally devised by Stampery , the leaders of blockchain-powered data certification. The protocol is now being developed by Witnet Foundation in collaboration with a community of independent contributors. Ever since Stampery was founded in 2014, they have been on a mission: replacing blind trust with mathematical proof. Witnet is the next step towards this goal. Stampery is backed by top venture capital funds and angel investors, including Tim Draper and Blockchain Capital. The Stampery team has also been involved in the development of Aragon , Trailbot , Mongoaudit and Loqui IM . Otherwise, the contracts could have totally different output values when executed across all the nodes maintaining the blockchain, therefore causing inconsistencies that would lead to breaking the network consensus. \u21a9","title":"Who Is Behind Witnet"},{"location":"get-started/why-rust/","text":"Why Rust? \u00b6 Having its own underlying blockchain, Witnet requires code that is as fast as C or C++ but memory safe to prevent security vulnerabilities. At the same time, we want to produce concurrent code that can take advantage of modern hardware. After analyzing the possible languages to use, we found that Rust is a fast, memory safe and highly concurrent language which allows for writing complex multithreaded code without race conditions or dangling pointers. It allows fearless concurrency without compromising on performance. Having an undeniable influence from functional languages like ML or Haskell, Rust is very expressive yet it uses high level abstractions. This makes it easy to write correct and readable code, which in turn translates into faster and more productive development. Rust is statically typed but it sports a really nice type inferer which makes code succinct and readable. The absence of a garbage collector and low runtime requirements makes it easy to embed Rust code inside other languages like Python, Ruby or Nodejs. This is fundamental for building the bridges between Witnet and other blockchains as well as with the headless browser that will allow Witnet to perform web content retrievals. The Rust compiler is simply awesome, offering the most helpful messages we have seen in a compiler. It also has incremental compilation, which helps developers save their valuable time. No more reinventing the wheel. Unlike C or C++, Rust has a package manager\u200a\u2014\u200aa tool called cargo. Besides managing the dependencies of the project, cargo gives you the option to build, run, test, generate documentation and publish your own package to a community driven package repository. Metaprogramming. Rust macros allow for reusing code in a concise, well-abstracted way with a powerful compile-time correctness checking. And last but not least, Rust has an ever-welcoming community that is always willing to help and is currently growing at a very healthy pace. In addition, it is currently in a stage in which the ecosystem is mature enough so that you d Summing up, here are the 8 reasons why Witnet will make the most of Rust: Performance Memory safety Concurrency Influence from functional languages Statically typed with type inference Awesome compiler and tooling Metaprogramming Thriving community Tip By the way, do you love Rust and want to join one of the most exciting projects using it in the blockchain space? We\u2019re hiring! See our current open positions on AngelList .","title":"Why Rust?"},{"location":"get-started/why-rust/#why-rust","text":"Having its own underlying blockchain, Witnet requires code that is as fast as C or C++ but memory safe to prevent security vulnerabilities. At the same time, we want to produce concurrent code that can take advantage of modern hardware. After analyzing the possible languages to use, we found that Rust is a fast, memory safe and highly concurrent language which allows for writing complex multithreaded code without race conditions or dangling pointers. It allows fearless concurrency without compromising on performance. Having an undeniable influence from functional languages like ML or Haskell, Rust is very expressive yet it uses high level abstractions. This makes it easy to write correct and readable code, which in turn translates into faster and more productive development. Rust is statically typed but it sports a really nice type inferer which makes code succinct and readable. The absence of a garbage collector and low runtime requirements makes it easy to embed Rust code inside other languages like Python, Ruby or Nodejs. This is fundamental for building the bridges between Witnet and other blockchains as well as with the headless browser that will allow Witnet to perform web content retrievals. The Rust compiler is simply awesome, offering the most helpful messages we have seen in a compiler. It also has incremental compilation, which helps developers save their valuable time. No more reinventing the wheel. Unlike C or C++, Rust has a package manager\u200a\u2014\u200aa tool called cargo. Besides managing the dependencies of the project, cargo gives you the option to build, run, test, generate documentation and publish your own package to a community driven package repository. Metaprogramming. Rust macros allow for reusing code in a concise, well-abstracted way with a powerful compile-time correctness checking. And last but not least, Rust has an ever-welcoming community that is always willing to help and is currently growing at a very healthy pace. In addition, it is currently in a stage in which the ecosystem is mature enough so that you d Summing up, here are the 8 reasons why Witnet will make the most of Rust: Performance Memory safety Concurrency Influence from functional languages Statically typed with type inference Awesome compiler and tooling Metaprogramming Thriving community Tip By the way, do you love Rust and want to join one of the most exciting projects using it in the blockchain space? We\u2019re hiring! See our current open positions on AngelList .","title":"Why Rust?"}]}
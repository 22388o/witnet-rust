{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Witnet-rust \u00b6 Witnet-rust is an open-source implementation of the Witnet protocol written in Rust. The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central to incentivizing the network players to abide by the protocol and make them liable for any misbehavior. Active network participants will earn wit tokens for fulfilling the data retrieval, attestation and delivery tasks coming from different smart contract platforms such as Ethereum and RChain. Witnet-rust is the first open-source implementation of the Witnet protocol and leverages the Rust programming language to achieve utmost speed, memory safety and fearless concurrency without compromising on performance. Tip See \" Why Rust? \" for a more technical overview on why we chose Rust. Get started \u00b6 Installation \u00b6 Witnet-rust is an open-source native app providing \"full node\" functionality of the Witnet Decentralized Oracle Network protocol. It is available under the GNU General Public License v3.0 . You may refer to the installation guide in order to install the app together with its dependencies. Roadmap \u00b6 Witnet-rust is an ambitious effort in its early days. We are currently working towards launching our first testnet. As you can guess from our datailed roadmap and GitHub issues , there are still a lot of missing features (and a whole lot more that would be nice to have yet not critical for our testnet launch). Contributing \u00b6 See the contributing guide to get more information on how to contribute to Rust-witnet development, and the roadmap to find out what features are coming soon.","title":"Home"},{"location":"#witnet-rust","text":"Witnet-rust is an open-source implementation of the Witnet protocol written in Rust. The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central to incentivizing the network players to abide by the protocol and make them liable for any misbehavior. Active network participants will earn wit tokens for fulfilling the data retrieval, attestation and delivery tasks coming from different smart contract platforms such as Ethereum and RChain. Witnet-rust is the first open-source implementation of the Witnet protocol and leverages the Rust programming language to achieve utmost speed, memory safety and fearless concurrency without compromising on performance. Tip See \" Why Rust? \" for a more technical overview on why we chose Rust.","title":"Witnet-rust"},{"location":"#get-started","text":"","title":"Get started"},{"location":"#installation","text":"Witnet-rust is an open-source native app providing \"full node\" functionality of the Witnet Decentralized Oracle Network protocol. It is available under the GNU General Public License v3.0 . You may refer to the installation guide in order to install the app together with its dependencies.","title":"Installation"},{"location":"#roadmap","text":"Witnet-rust is an ambitious effort in its early days. We are currently working towards launching our first testnet. As you can guess from our datailed roadmap and GitHub issues , there are still a lot of missing features (and a whole lot more that would be nice to have yet not critical for our testnet launch).","title":"Roadmap"},{"location":"#contributing","text":"See the contributing guide to get more information on how to contribute to Rust-witnet development, and the roadmap to find out what features are coming soon.","title":"Contributing"},{"location":"contributing/","text":"Contributing to Witnet-rust \u00b6 Thank you for being interested in contributing to Witnet! The following is a set of guidelines and helpful pointers for contributing to Witnet The keyword here is guidelines, not rules. As such, use your best judgement and feel free to propose changes to even this document. Code of conduct \u00b6 Everyone participating in this project is governed by the Witnet Code of Conduct . By participating, you are expected to uphold this code as well. I just have a question \u00b6 Please don't file an issue with questions. It's easier for you and for us if you go directly to our Gitter chatroom , since it will keep our repositories clean and you will get a faster response. How can I contribute? \u00b6 Find an area you can help with and do it. Open source is about collaboration and open participation. Try to make your code look like what already exists and submit a pull request. The list of issues is a good place to start, especially the ones tagged as \"good first issue\" or \"help wanted\" (but don't let that stop you from looking at others). If you're looking for additional ideas, the code includes TODO comments for minor to major improvements. Grep is your friend. Additional tests are rewarded with an immense amount of positive karma. More documentation or updates/fixes to existing documentation are also very welcome. However, if submitting a PR consisting of documentation changes only, please try to ensure that the change is significantly more substantial than one or two lines. For example, working through an install document and making changes and updates throughout as you find issues is worth a PR. For typos and other small changes, either contact one of the developers, or if you think it's a significant enough error to cause problems for other users, please feel free to open an issue. Reporting bugs \u00b6 This section guides you through submitting a bug report. This helps contributors and maintainers understand your report, reproduce the behavior, and in turn squash the bug. Before submitting a bug report, please make sure that you've searched through the issues and that there isn't already an issue describing the same issue you are having. How do I submit a good bug report? \u00b6 Bugs are tracked as GitHub issues . Explain the problem and include additional details to help maintainers reproduce the problem: Use a clear and descriptive title for the issue to identify the problem. Describe the exact steps which reproduce the problem in as many details as possible. Provide specific examples to demonstrate the steps. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use Markdown code blocks. Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior. Explain which behavior you expected to see instead and why. Post a screenshot or a dump of the developer console If the problem wasn't triggered by a specific action, describe what you were doing before the problem happened and share more information using the guidelines below. Provide more context by answering these questions: Did the problem start happening recently (e.g. after updating to a new version) or was this always a problem? If the problem started happening recently, can you reproduce the problem in an older version of Witnet-rust? What's the most recent version in which the problem doesn't happen? Can you reliably reproduce the issue? If not, provide details about how often the problem happens and under which conditions it normally happens. Include details about your configuration and environment: Which version of rustc are you using? You can get the exact version by running rustc --version --verbose in your terminal. What's your operating system and version? Suggesting enhancements \u00b6 This section guides you through submitting an enhancement suggestion, including completely new features and minor improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion. Before creating enhancement suggestions, please double check that there is not already an existing feature suggestion for your feature, as you might find out that you don't need to create one. When you are creating an enhancement suggestion, please include as many details as possible. How Do I Submit A Good Enhancement Suggestion? \u00b6 Enhancement suggestions are tracked as GitHub issues. Create an issue on that repository and provide the following information: Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Provide specific examples to demonstrate the steps. Include copy/pasteable snippets which you use in those examples, as Markdown code blocks. Describe the current behavior and explain which behavior you expected to see instead and why. Explain why this enhancement would be useful to most users and isn't something that can or should be implemented as a community package. Your First Code Contribution \u00b6 Unsure where to begin contributing? You can start by looking through these good first issue issues: Good first issue - issues which should only require a few lines of code, and a test or two. Copyright \u00b6 These guidelines are inspired by: AragonJS Contributing Guidelines , published under the Creative Commons Zero v1.0 Universal License . Grin Contributing Guide , published under the Apache License 2.0 .","title":"Contributing"},{"location":"contributing/#contributing-to-witnet-rust","text":"Thank you for being interested in contributing to Witnet! The following is a set of guidelines and helpful pointers for contributing to Witnet The keyword here is guidelines, not rules. As such, use your best judgement and feel free to propose changes to even this document.","title":"Contributing to Witnet-rust"},{"location":"contributing/#code-of-conduct","text":"Everyone participating in this project is governed by the Witnet Code of Conduct . By participating, you are expected to uphold this code as well.","title":"Code of conduct"},{"location":"contributing/#i-just-have-a-question","text":"Please don't file an issue with questions. It's easier for you and for us if you go directly to our Gitter chatroom , since it will keep our repositories clean and you will get a faster response.","title":"I just have a question"},{"location":"contributing/#how-can-i-contribute","text":"Find an area you can help with and do it. Open source is about collaboration and open participation. Try to make your code look like what already exists and submit a pull request. The list of issues is a good place to start, especially the ones tagged as \"good first issue\" or \"help wanted\" (but don't let that stop you from looking at others). If you're looking for additional ideas, the code includes TODO comments for minor to major improvements. Grep is your friend. Additional tests are rewarded with an immense amount of positive karma. More documentation or updates/fixes to existing documentation are also very welcome. However, if submitting a PR consisting of documentation changes only, please try to ensure that the change is significantly more substantial than one or two lines. For example, working through an install document and making changes and updates throughout as you find issues is worth a PR. For typos and other small changes, either contact one of the developers, or if you think it's a significant enough error to cause problems for other users, please feel free to open an issue.","title":"How can I contribute?"},{"location":"contributing/#reporting-bugs","text":"This section guides you through submitting a bug report. This helps contributors and maintainers understand your report, reproduce the behavior, and in turn squash the bug. Before submitting a bug report, please make sure that you've searched through the issues and that there isn't already an issue describing the same issue you are having.","title":"Reporting bugs"},{"location":"contributing/#how-do-i-submit-a-good-bug-report","text":"Bugs are tracked as GitHub issues . Explain the problem and include additional details to help maintainers reproduce the problem: Use a clear and descriptive title for the issue to identify the problem. Describe the exact steps which reproduce the problem in as many details as possible. Provide specific examples to demonstrate the steps. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use Markdown code blocks. Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior. Explain which behavior you expected to see instead and why. Post a screenshot or a dump of the developer console If the problem wasn't triggered by a specific action, describe what you were doing before the problem happened and share more information using the guidelines below. Provide more context by answering these questions: Did the problem start happening recently (e.g. after updating to a new version) or was this always a problem? If the problem started happening recently, can you reproduce the problem in an older version of Witnet-rust? What's the most recent version in which the problem doesn't happen? Can you reliably reproduce the issue? If not, provide details about how often the problem happens and under which conditions it normally happens. Include details about your configuration and environment: Which version of rustc are you using? You can get the exact version by running rustc --version --verbose in your terminal. What's your operating system and version?","title":"How do I submit a good bug report?"},{"location":"contributing/#suggesting-enhancements","text":"This section guides you through submitting an enhancement suggestion, including completely new features and minor improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion. Before creating enhancement suggestions, please double check that there is not already an existing feature suggestion for your feature, as you might find out that you don't need to create one. When you are creating an enhancement suggestion, please include as many details as possible.","title":"Suggesting enhancements"},{"location":"contributing/#how-do-i-submit-a-good-enhancement-suggestion","text":"Enhancement suggestions are tracked as GitHub issues. Create an issue on that repository and provide the following information: Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Provide specific examples to demonstrate the steps. Include copy/pasteable snippets which you use in those examples, as Markdown code blocks. Describe the current behavior and explain which behavior you expected to see instead and why. Explain why this enhancement would be useful to most users and isn't something that can or should be implemented as a community package.","title":"How Do I Submit A Good Enhancement Suggestion?"},{"location":"contributing/#your-first-code-contribution","text":"Unsure where to begin contributing? You can start by looking through these good first issue issues: Good first issue - issues which should only require a few lines of code, and a test or two.","title":"Your First Code Contribution"},{"location":"contributing/#copyright","text":"These guidelines are inspired by: AragonJS Contributing Guidelines , published under the Creative Commons Zero v1.0 Universal License . Grin Contributing Guide , published under the Apache License 2.0 .","title":"Copyright"},{"location":"development/","text":"Development \u00b6 Witnet-rust is build using The Rust Programming language and following rust2018 edition guide . Installing \u00b6 Install dependencies Rust 1.31 (currently on the nightly release channel) flatc FlatBuffers compiler (optional, only if recompiling schemas) Clone the source code from github: 1 2 $ git clone https://github.com/witnet/witnet-rust.git $ cd witnet-rust Use cargo to install just . 1 $ cargo install just Run just script to install dev tools 1 $ just install-setup Run a witnet component. Find a list of components and how to run them at CLI . 1 2 3 $ RUST_LOG = witnet = trace cargo run server or $ just server CLI \u00b6 Synopsis \u00b6 1 2 RUST_LOG=witnet=[error | info | debug | main | trace] cargo run [server [ --address address] [--peer peer-address] [--background]] Components \u00b6 Server \u00b6 --address <address> Read server address from <address> argument. --peer <peer-address> Read address to peer from <peer-address> argument. --background Not implemented. Development Scripts \u00b6 There are some usefull scripts to run with just : clippy : Run clippy style checking. docs-build : Compile docs into static files. docs-deploy : Deploy compiled docs into gh-pages branch. docs-dev : Run local documentation server at localhost:8000 fmt : Run code formatter. install-clippy . Install clippy library. install-rustfmt : Install rustfmt library. install-setup : Install dev tools. server : Run witnet server component. travis : Run travis build.","title":"Development"},{"location":"development/#development","text":"Witnet-rust is build using The Rust Programming language and following rust2018 edition guide .","title":"Development"},{"location":"development/#installing","text":"Install dependencies Rust 1.31 (currently on the nightly release channel) flatc FlatBuffers compiler (optional, only if recompiling schemas) Clone the source code from github: 1 2 $ git clone https://github.com/witnet/witnet-rust.git $ cd witnet-rust Use cargo to install just . 1 $ cargo install just Run just script to install dev tools 1 $ just install-setup Run a witnet component. Find a list of components and how to run them at CLI . 1 2 3 $ RUST_LOG = witnet = trace cargo run server or $ just server","title":"Installing"},{"location":"development/#cli","text":"","title":"CLI"},{"location":"development/#synopsis","text":"1 2 RUST_LOG=witnet=[error | info | debug | main | trace] cargo run [server [ --address address] [--peer peer-address] [--background]]","title":"Synopsis"},{"location":"development/#components","text":"","title":"Components"},{"location":"development/#server","text":"--address <address> Read server address from <address> argument. --peer <peer-address> Read address to peer from <peer-address> argument. --background Not implemented.","title":"Server"},{"location":"development/#development-scripts","text":"There are some usefull scripts to run with just : clippy : Run clippy style checking. docs-build : Compile docs into static files. docs-deploy : Deploy compiled docs into gh-pages branch. docs-dev : Run local documentation server at localhost:8000 fmt : Run code formatter. install-clippy . Install clippy library. install-rustfmt : Install rustfmt library. install-setup : Install dev tools. server : Run witnet server component. travis : Run travis build.","title":"Development Scripts"},{"location":"architecture/storage/","text":"Persistent Storage \u00b6 From the perspective of software architecture, persistent storage is one of the key elements to maintaining a distributed block chain. Its role is allowing nodes in the network to preserve important data structures that need to be kept over time for trustless validation of new chain objects. Namely, those structures are: The UTXO set Data requests Transactions Blocks Generic Storage Trait \u00b6 Witnet-rust features a generic Storage Rust trait ( storage.rs ) that exposes a key/value API with the elemental CRUD methods (create, read, update, delete) while abstracting away from specific storage backend implementations. 1 pub trait Storage < ConnData , Key , Value > { /** **/ } The meaning of the generic types is the following: Generic type Description ConnData Type of the data needed by the constructor for creating a connection to the storage backend. Key Type of the keys used to identify the records in the storage. Value Type of the values in the storage. As of PR #21 , Witnet-rust incorporates implementations for the following storage backends: rocks.rs : persists data into the local file system using the performant RocksDB engine. in_memory.rs : keeps data in a HashMap that lives in the memory heap. Warning In-memory storage is implemented only for the sake of testing the Storage trait. It is obviously not a viable persistence solution as data is totally wiped as soon as references to the storage go out of scope or the app dies. Instantiation \u00b6 All implementors of the Storage trait can be instantiated with the witnet_storage::storage::new() constructor, which must be used as a static method. Signature 1 fn new ( connection_data : ConnData ) -> Result < Box < Self >> ; Tip Please note that the witnet_storage::storage::new() method wraps the return type into a Box . This is to ensure the value is allocated into the heap and to allow a reference to it (the Box itself) to outlive the constructor. Example 1 2 3 use witnet_storage :: backends :: in_memory :: InMemoryStorage ; let storage : & InMemoryStorage = InMemoryStorage :: new (). unwrap (); Creating and updating records with the put() Method \u00b6 The witnet_storage::storage::put() method allows creating or replacing a value in the storage under a certain key. Signature 1 fn put ( & mut self , key : Key , value : Value ) -> Result < () > ; Example 1 2 3 4 // Put value \"bar\" into key \"foo\" storage . put ( b\"foo\" , b\"bar\" . to_vec ()) ? ; // Update value of \"foo\" to be \"beer\" storage . put ( b\"foo\" , b\"beer\" . to_vec ()) ? ; Getting records with the get() method \u00b6 The witnet_storage::storage::get() method allows reading the value in the storage under a certain key. Signature 1 fn get ( & self , key : Key ) -> Result < Option < Value >> ; Example 1 2 3 4 5 match storage . get ( b\"foo\" ) { Ok ( Some ( value )) => , // Found a value Ok ( None ) => , // The key didn't exist Err ( error ) => // Error while reading } Deleting records with the delete() method \u00b6 The witnet_storage::storage::delete() method allows deleting a record in the storage given its key. Signature 1 fn delete ( & mut self , key : Key ) -> Result < () > ; Example 1 storage . delete ( b\"foo\" ) ? ; RocksDB Storage Backend \u00b6 The RocksDB storage backend ( rocks.rs ) is one of the bundled storage backends in Witnet-rust. It implements all the methods of the Storage trait for the RocksStorage struct: 1 2 3 4 5 /// Data structure for the RocksDB storage whose only member is a /// rocksdb::DB object. pub struct RocksStorage { db : DB } The actual implementor looks like this (function bodies and some lifetime annotations have been omitted for brevity): 1 2 3 4 5 6 7 8 9 10 11 12 13 // Implement the Storage generic trait for the RocksStorage storage // data structure. impl Storage <& str , & [ u8 ], Vec < u8 >> for RocksStorage { fn new ( path : & str ) -> Result < Box < Self >> ; fn put ( & mut self , key : & [ u8 ], value : Vec < u8 > ) -> Result < () > ; fn get ( & self , key : & [ u8 ]) -> Result < Option < Vec < u8 >>> ; fn delete ( & mut self , key : & [ u8 ]) -> Result < () > ; } These are the specific types for this implementor: Generic type Specific type ConnData &str Key &[u8] Value Vec<u8> The full source code of the Storage implementor for RocksStorage can be found at rocks.rs .","title":"Persistent Storage"},{"location":"architecture/storage/#persistent-storage","text":"From the perspective of software architecture, persistent storage is one of the key elements to maintaining a distributed block chain. Its role is allowing nodes in the network to preserve important data structures that need to be kept over time for trustless validation of new chain objects. Namely, those structures are: The UTXO set Data requests Transactions Blocks","title":"Persistent Storage"},{"location":"architecture/storage/#generic-storage-trait","text":"Witnet-rust features a generic Storage Rust trait ( storage.rs ) that exposes a key/value API with the elemental CRUD methods (create, read, update, delete) while abstracting away from specific storage backend implementations. 1 pub trait Storage < ConnData , Key , Value > { /** **/ } The meaning of the generic types is the following: Generic type Description ConnData Type of the data needed by the constructor for creating a connection to the storage backend. Key Type of the keys used to identify the records in the storage. Value Type of the values in the storage. As of PR #21 , Witnet-rust incorporates implementations for the following storage backends: rocks.rs : persists data into the local file system using the performant RocksDB engine. in_memory.rs : keeps data in a HashMap that lives in the memory heap. Warning In-memory storage is implemented only for the sake of testing the Storage trait. It is obviously not a viable persistence solution as data is totally wiped as soon as references to the storage go out of scope or the app dies.","title":"Generic Storage Trait"},{"location":"architecture/storage/#instantiation","text":"All implementors of the Storage trait can be instantiated with the witnet_storage::storage::new() constructor, which must be used as a static method. Signature 1 fn new ( connection_data : ConnData ) -> Result < Box < Self >> ; Tip Please note that the witnet_storage::storage::new() method wraps the return type into a Box . This is to ensure the value is allocated into the heap and to allow a reference to it (the Box itself) to outlive the constructor. Example 1 2 3 use witnet_storage :: backends :: in_memory :: InMemoryStorage ; let storage : & InMemoryStorage = InMemoryStorage :: new (). unwrap ();","title":"Instantiation"},{"location":"architecture/storage/#creating-and-updating-records-with-the-put-method","text":"The witnet_storage::storage::put() method allows creating or replacing a value in the storage under a certain key. Signature 1 fn put ( & mut self , key : Key , value : Value ) -> Result < () > ; Example 1 2 3 4 // Put value \"bar\" into key \"foo\" storage . put ( b\"foo\" , b\"bar\" . to_vec ()) ? ; // Update value of \"foo\" to be \"beer\" storage . put ( b\"foo\" , b\"beer\" . to_vec ()) ? ;","title":"Creating and updating records with the put() Method"},{"location":"architecture/storage/#getting-records-with-the-get-method","text":"The witnet_storage::storage::get() method allows reading the value in the storage under a certain key. Signature 1 fn get ( & self , key : Key ) -> Result < Option < Value >> ; Example 1 2 3 4 5 match storage . get ( b\"foo\" ) { Ok ( Some ( value )) => , // Found a value Ok ( None ) => , // The key didn't exist Err ( error ) => // Error while reading }","title":"Getting records with the get() method"},{"location":"architecture/storage/#deleting-records-with-the-delete-method","text":"The witnet_storage::storage::delete() method allows deleting a record in the storage given its key. Signature 1 fn delete ( & mut self , key : Key ) -> Result < () > ; Example 1 storage . delete ( b\"foo\" ) ? ;","title":"Deleting records with the delete() method"},{"location":"architecture/storage/#rocksdb-storage-backend","text":"The RocksDB storage backend ( rocks.rs ) is one of the bundled storage backends in Witnet-rust. It implements all the methods of the Storage trait for the RocksStorage struct: 1 2 3 4 5 /// Data structure for the RocksDB storage whose only member is a /// rocksdb::DB object. pub struct RocksStorage { db : DB } The actual implementor looks like this (function bodies and some lifetime annotations have been omitted for brevity): 1 2 3 4 5 6 7 8 9 10 11 12 13 // Implement the Storage generic trait for the RocksStorage storage // data structure. impl Storage <& str , & [ u8 ], Vec < u8 >> for RocksStorage { fn new ( path : & str ) -> Result < Box < Self >> ; fn put ( & mut self , key : & [ u8 ], value : Vec < u8 > ) -> Result < () > ; fn get ( & self , key : & [ u8 ]) -> Result < Option < Vec < u8 >>> ; fn delete ( & mut self , key : & [ u8 ]) -> Result < () > ; } These are the specific types for this implementor: Generic type Specific type ConnData &str Key &[u8] Value Vec<u8> The full source code of the Storage implementor for RocksStorage can be found at rocks.rs .","title":"RocksDB Storage Backend"},{"location":"get-started/what-is-witnet/","text":"What is Witnet \u00b6 The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. Wait, what? Ok, lets go one step at a time. Smart Contracts Are Not What You Think \u00b6 Over the last years, blockchain technology has promised to revolutionize business by allowing creation of \"smart contracts\" that, unlike paper contracts, are impossible to breach. Actually, those smart contracts are nothing more than small programs that can be run in a trustless manner. That is: once they are created, no one can stop them from doing exactly what they were created for. They just obey their own source code, and censorship is just impossible. This is a really powerful idea. If you can write a smart contract that: implements the logic of an agreement, and can execute the clauses of the contract on its own (like paying Alice or Bob depending on the outcome of some event), then you have a contract that is capable of enforcing itself and leaves no room for contestation. Boom . Blockchain Oracles, And Their Problem \u00b6 Given that smart contracts need to be completely deterministic 1 , they do not support input of data from non-deterministic sources such as APIs or websites. As a result, smart contracts are mostly isolated from the rest of the Internet, which dramatically reduces their transformative potential. At the end of the day, the output of a program does not depend solely on its source code, but also on the input data it operates upon. Of course, as the creator of a smart contract, you can create a method that allows you and only you to act as an \"oracle\" by introducing information from the outside at will. But you would be completely breaking the trustless nature of a smart contract. If trust is put in a single entity, there you have a single point of failure that can easily be hacked or corrupted. Smart contracts connected to the real world will not be completely trustless and will not release their full potential until we have ways to feed them information trustlessly. This is often called \"the oracle problem\" . The Solution: A Decentralized Oracle Network \u00b6 The Witnet protocol aims to create an overlay network that connects smart contracts to any online data source. Sport results, stock prices, weather forecasts or even other blockchains can be easily queried (preferably through APIs). The protocol describes a distributed network of peer nodes\u2014which we fondly call witnesses \u2014who earn Wit tokens as a reward for retrieving web data and reporting it directly to the smart contracts. The bottom line is that a considerable number of randomly selected, anonymous peers retrieving information from one or more sources can converge into a single truth about the data they retrieved if a majority of them are incentivized to report the retrieved data honestly and they apply a common consensus algorithm that resolves inconsistencies. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central to incentivizing the network players to abide by the protocol and make them liable for any misbehavior. Witnesses are also in charge of validating transactions in the network and bundling them into blocks that get appended to the blockchain periodically. The process by which witnesses retrieve, attest and deliver data in behalf of the smart contracts is in some way similar to mining in other blockchains. However, fulfilling these tasks and collecting the rewards is not that expensive in terms of computation. The protocol has been conceived to ensure utmost decentralization and fairnes, so each witness' weight in the network is not aligned to their computing power. Instead, the probability for every witness to be assigned tasks or mine new blocks is directly proportional to their past performance in terms of honesty: their reputation. Tip Of course, the so-called miners are not actual human beings sitting in front of a computer, fulfilling assignments coming from an Internet overlord that commands them to use their web browser to navigate to a certain website and take a snapshot or copy some text that they must report. Indeed, the miners are just computers running a software (Witnet-rust) that automatically receive and execute a series of tasks without the owner of the computer having to actively do anything else than installing it. 100% Truth, 0% Trust \u00b6 Data retrieved, attested and delivered using the Witnet protocol is reliable not because of authority but because it comes from anonymous nodes who are incentivized to remain honest and to compete for rewards. In addition, integrity of this data is guaranteed by a consensus algorithm that detects fraudsters, who are immediately punished. The progressive reputation protocol plays a central role in maintaining every participant active and honest by creating short, middle and long term incentives for them to abide by the protocol and not to tamper with the data they broker. Info Please note that Witnet's aim is not spotting fake data, but guaranteeing a 1:1 match between what is published online\u2014regardless of its truthness\u2014and the data that is eventually delivered the smart contracts. Who Is Behind Witnet \u00b6 Witnet is an open source project originally devised by Stampery , the leaders of blockchain-powered data certification. The protocol is now being developed by Witnet Foundation in collaboration with a community of independent contributors. Ever since Stampery was founded in 2014, they have been on a mission: replacing blind trust with mathematical proof. Witnet is the next step towards this goal. Stampery is backed by top venture capital funds and angel investors, including Tim Draper and Blockchain Capital. The Stampery team has also been involved in the development of Aragon , Trailbot , Mongoaudit and Loqui IM . Otherwise, the contracts could have totally different output values when executed across all the nodes maintaining the blockchain, therefore causing inconsistencies that would lead to breaking the network consensus. \u21a9","title":"What is Witnet"},{"location":"get-started/what-is-witnet/#what-is-witnet","text":"The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. Wait, what? Ok, lets go one step at a time.","title":"What is Witnet"},{"location":"get-started/what-is-witnet/#smart-contracts-are-not-what-you-think","text":"Over the last years, blockchain technology has promised to revolutionize business by allowing creation of \"smart contracts\" that, unlike paper contracts, are impossible to breach. Actually, those smart contracts are nothing more than small programs that can be run in a trustless manner. That is: once they are created, no one can stop them from doing exactly what they were created for. They just obey their own source code, and censorship is just impossible. This is a really powerful idea. If you can write a smart contract that: implements the logic of an agreement, and can execute the clauses of the contract on its own (like paying Alice or Bob depending on the outcome of some event), then you have a contract that is capable of enforcing itself and leaves no room for contestation. Boom .","title":"Smart Contracts Are Not What You Think"},{"location":"get-started/what-is-witnet/#blockchain-oracles-and-their-problem","text":"Given that smart contracts need to be completely deterministic 1 , they do not support input of data from non-deterministic sources such as APIs or websites. As a result, smart contracts are mostly isolated from the rest of the Internet, which dramatically reduces their transformative potential. At the end of the day, the output of a program does not depend solely on its source code, but also on the input data it operates upon. Of course, as the creator of a smart contract, you can create a method that allows you and only you to act as an \"oracle\" by introducing information from the outside at will. But you would be completely breaking the trustless nature of a smart contract. If trust is put in a single entity, there you have a single point of failure that can easily be hacked or corrupted. Smart contracts connected to the real world will not be completely trustless and will not release their full potential until we have ways to feed them information trustlessly. This is often called \"the oracle problem\" .","title":"Blockchain Oracles, And Their Problem"},{"location":"get-started/what-is-witnet/#the-solution-a-decentralized-oracle-network","text":"The Witnet protocol aims to create an overlay network that connects smart contracts to any online data source. Sport results, stock prices, weather forecasts or even other blockchains can be easily queried (preferably through APIs). The protocol describes a distributed network of peer nodes\u2014which we fondly call witnesses \u2014who earn Wit tokens as a reward for retrieving web data and reporting it directly to the smart contracts. The bottom line is that a considerable number of randomly selected, anonymous peers retrieving information from one or more sources can converge into a single truth about the data they retrieved if a majority of them are incentivized to report the retrieved data honestly and they apply a common consensus algorithm that resolves inconsistencies. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central to incentivizing the network players to abide by the protocol and make them liable for any misbehavior. Witnesses are also in charge of validating transactions in the network and bundling them into blocks that get appended to the blockchain periodically. The process by which witnesses retrieve, attest and deliver data in behalf of the smart contracts is in some way similar to mining in other blockchains. However, fulfilling these tasks and collecting the rewards is not that expensive in terms of computation. The protocol has been conceived to ensure utmost decentralization and fairnes, so each witness' weight in the network is not aligned to their computing power. Instead, the probability for every witness to be assigned tasks or mine new blocks is directly proportional to their past performance in terms of honesty: their reputation. Tip Of course, the so-called miners are not actual human beings sitting in front of a computer, fulfilling assignments coming from an Internet overlord that commands them to use their web browser to navigate to a certain website and take a snapshot or copy some text that they must report. Indeed, the miners are just computers running a software (Witnet-rust) that automatically receive and execute a series of tasks without the owner of the computer having to actively do anything else than installing it.","title":"The Solution: A Decentralized Oracle Network"},{"location":"get-started/what-is-witnet/#100-truth-0-trust","text":"Data retrieved, attested and delivered using the Witnet protocol is reliable not because of authority but because it comes from anonymous nodes who are incentivized to remain honest and to compete for rewards. In addition, integrity of this data is guaranteed by a consensus algorithm that detects fraudsters, who are immediately punished. The progressive reputation protocol plays a central role in maintaining every participant active and honest by creating short, middle and long term incentives for them to abide by the protocol and not to tamper with the data they broker. Info Please note that Witnet's aim is not spotting fake data, but guaranteeing a 1:1 match between what is published online\u2014regardless of its truthness\u2014and the data that is eventually delivered the smart contracts.","title":"100% Truth, 0% Trust"},{"location":"get-started/what-is-witnet/#who-is-behind-witnet","text":"Witnet is an open source project originally devised by Stampery , the leaders of blockchain-powered data certification. The protocol is now being developed by Witnet Foundation in collaboration with a community of independent contributors. Ever since Stampery was founded in 2014, they have been on a mission: replacing blind trust with mathematical proof. Witnet is the next step towards this goal. Stampery is backed by top venture capital funds and angel investors, including Tim Draper and Blockchain Capital. The Stampery team has also been involved in the development of Aragon , Trailbot , Mongoaudit and Loqui IM . Otherwise, the contracts could have totally different output values when executed across all the nodes maintaining the blockchain, therefore causing inconsistencies that would lead to breaking the network consensus. \u21a9","title":"Who Is Behind Witnet"},{"location":"get-started/why-rust/","text":"Why Rust? \u00b6 Having its own underlying blockchain, Witnet requires code that is as fast as C or C++ but memory safe to prevent security vulnerabilities. At the same time, we want to produce concurrent code that can take advantage of modern hardware. After analyzing the possible languages to use, we found that Rust is a fast, memory safe and highly concurrent language which allows for writing complex multithreaded code without race conditions or dangling pointers. It allows fearless concurrency without compromising on performance. Having an undeniable influence from functional languages like ML or Haskell, Rust is very expressive yet it uses high level abstractions. This makes it easy to write correct and readable code, which in turn translates into faster and more productive development. Rust is statically typed but it sports a really nice type inferer which makes code succinct and readable. The absence of a garbage collector and low runtime requirements makes it easy to embed Rust code inside other languages like Python, Ruby or Nodejs. This is fundamental for building the bridges between Witnet and other blockchains as well as with the headless browser that will allow Witnet to perform web content retrievals. The Rust compiler is simply awesome, offering the most helpful messages we have seen in a compiler. It also has incremental compilation, which helps developers save their valuable time. No more reinventing the wheel. Unlike C or C++, Rust has a package manager\u200a\u2014\u200aa tool called cargo. Besides managing the dependencies of the project, cargo gives you the option to build, run, test, generate documentation and publish your own package to a community driven package repository. Metaprogramming. Rust macros allow for reusing code in a concise, well-abstracted way with a powerful compile-time correctness checking. And last but not least, Rust has an ever-welcoming community that is always willing to help and is currently growing at a very healthy pace. In addition, it is currently in a stage in which the ecosystem is mature enough so that you d Summing up, here are the 8 reasons why Witnet will make the most of Rust: Performance Memory safety Concurrency Influence from functional languages Statically typed with type inference Awesome compiler and tooling Metaprogramming Thriving community Tip By the way, do you love Rust and want to join one of the most exciting projects using it in the blockchain space? We\u2019re hiring! See our current open positions on AngelList .","title":"Why Rust?"},{"location":"get-started/why-rust/#why-rust","text":"Having its own underlying blockchain, Witnet requires code that is as fast as C or C++ but memory safe to prevent security vulnerabilities. At the same time, we want to produce concurrent code that can take advantage of modern hardware. After analyzing the possible languages to use, we found that Rust is a fast, memory safe and highly concurrent language which allows for writing complex multithreaded code without race conditions or dangling pointers. It allows fearless concurrency without compromising on performance. Having an undeniable influence from functional languages like ML or Haskell, Rust is very expressive yet it uses high level abstractions. This makes it easy to write correct and readable code, which in turn translates into faster and more productive development. Rust is statically typed but it sports a really nice type inferer which makes code succinct and readable. The absence of a garbage collector and low runtime requirements makes it easy to embed Rust code inside other languages like Python, Ruby or Nodejs. This is fundamental for building the bridges between Witnet and other blockchains as well as with the headless browser that will allow Witnet to perform web content retrievals. The Rust compiler is simply awesome, offering the most helpful messages we have seen in a compiler. It also has incremental compilation, which helps developers save their valuable time. No more reinventing the wheel. Unlike C or C++, Rust has a package manager\u200a\u2014\u200aa tool called cargo. Besides managing the dependencies of the project, cargo gives you the option to build, run, test, generate documentation and publish your own package to a community driven package repository. Metaprogramming. Rust macros allow for reusing code in a concise, well-abstracted way with a powerful compile-time correctness checking. And last but not least, Rust has an ever-welcoming community that is always willing to help and is currently growing at a very healthy pace. In addition, it is currently in a stage in which the ecosystem is mature enough so that you d Summing up, here are the 8 reasons why Witnet will make the most of Rust: Performance Memory safety Concurrency Influence from functional languages Statically typed with type inference Awesome compiler and tooling Metaprogramming Thriving community Tip By the way, do you love Rust and want to join one of the most exciting projects using it in the blockchain space? We\u2019re hiring! See our current open positions on AngelList .","title":"Why Rust?"},{"location":"protocol/network/","text":"Witnet Network Protocol \u00b6 Witnet network protocol is inspired in other blockchain network protocols such as Bitcoin, Ethereum and Rchain. Additionally, other blockchains such as Grin and Exonum have been taken into consideration as their reference implementations are coded in Rust. Initial considerations \u00b6 In order to start the network discovery process, at least one existing node on the network is required. However, in order to avoid unnecessary risks or potential attack vectors, it is always recommended to know several existing nodes extracted from different sources. Peer bootstrapping methods \u00b6 The strategy for selecting the first node to connect should be random, thus it should not depend on geographical position or any other network parameter. The client discovers the IP addresses and ports of other nodes in a decentralized way, i.e. there should not be a central point of trust or failure to bootstrap the network. For example, some of the considered approaches for bootstrapping a new peer into the network could one or more of the following methods: Hard coded addresses Addresses provided as command line arguments Addresses provided from user provided text file on startup Store addresses in database and read them on startup Exchange addresses with other nodes DNS requests to receive IP addresses IRC channel where peers are advertised Constants and Defaults \u00b6 Witnet constants and default values used in the network protocol. Default Values \u00b6 Network Default Port mainnet 11337 testnet 21337 Witnet versions \u00b6 Below the existing versions of the Witnet P2P network protocol are listed: Version Initial Release Major Changes 010 to be determined Magic numbers \u00b6 These constant values indicate the originating network in the message headers: Network Magic number mainnet 0x00 testnet 0xF0 Node capabilities \u00b6 Currently, only one node capabilities is being offered by Witnet: Flag Description 0x0000000000000001 NODE_NETWORK, Witnet full node which is the default operation mode User agents \u00b6 Currently, only one user agent is being developed: User Agent Description /Witnet-rust:0.1.0 Witnet node implemented in Rust and version 0.1.0 Common Structures \u00b6 Common structures used along different Witnet network messages. Address Format \u00b6 Witnet peer addresses are defined as follows: Field Type Description ipv4 u32 IPv4 address of the peer port u16 port number in which the peer is listening Alternatively, IP addresses may be IPv6: Field Type Description ipv6 [u32; 4] IPv6 address of the peer port u16 port number in which the peer is listening Messages \u00b6 The current network protocol includes the description and definition of the following messages: VERSION VERACK GET_PEERS PEERS PING PONG All of these messages include a message header identifying which message type is being sent. Message Header \u00b6 Inspired in other blockchains, the message header format is composed of the following fields: Field Type Description magic u16 magic value indicating message origin network command string message being sent from a predefined list of available commands payload ? message data Handshake (VERSION, VERACK) \u00b6 The protocol to connect from a local peer (initiator) to a known remote peer, also known as \"handshake\", starts with a TCP connection to a given IP address and port. The handshake initiator, the local peer, sends a version message to the remote peer. The remote peer will analyze the information in order to evaluate if the submitting peer is compatible regarding their supported versions and capabilities. If so, the remote peer will acknowledge the version message and establish a connection by sending a verack message. The version message contains the following information: Field Type Description version u32 the Witnet p2p protocol version that the client is using timestamp u64 the current time in UTC format capabilities u64 list of flags of supported services, by default NODE_NETWORK is used sender_address addr the IP address and port of the handshake initiator peer receiver_address addr the IP address and port of the remote peer user_agent string a version showing which software is running the local peer last_epoch u32 last epoch in the local peer blockchain genesis [u32; 8] hash of the genesis block nonce u64 Node random nonce, randomly generated every time a version packet is sent (used to detect connections to self) The verack message is sent as reply to the version and it only consists of a message header with the command VERACK . Subsequently, the handshake initiator will expect a version message from the remote peer. The local peer will also acknowledge by replying with a verack message. Connection cannot be considered as establish until both verack messages have been received by both peers. After sending a version message the peers will define a timeout to wait for a response. If no response is received during this timeout (usually set to 10 seconds), the peer will be discarded from the known peers list. Peer discovery (GET_PEERS, PEERS) \u00b6 In Witnet, a node must always establish different paths into the network by connecting to different peers, ideally randomly selected. As connections may disappear, network peers should assist others when they bootstrap. After establishing a connection with remote peers (throughout a handshake mechanism), a node may request to their remote peer to receive a list of their known \"recent\" peers. This request is initiated by sending a get_peers message to a remote peer. The receiving node will reply with a peers message with a list of peer addresses that have been seen recently active in the network. The typical assumption is that a node is likely to be active if it has sent any message during the last 90 minutes. The transmitting node will then update those IP addresses and ports into its database of available nodes. The get_peers message only consists of the message header with the command GET_PEERS . The peers message consists of the message header with the command PEERS and as payload it contains a list of known peers as: Field Type Description peers addr[] list of addresses of active known peers Heartbeat (PING, PONG) \u00b6 As in Bitcoin, the heartbeat protocol is defined with ping and pong messages and it is defined as follows: If during the last 30 minutes a peer has no transmitted any message, it will send a heartbeat as ping message. If in the last 90 minutes no message has been received by a remote peer, the local node will assume that the connection has been closed. The ping message confirms that the connection is still valid. The pong message is sent in response to a ping message. Both contain only one field: Field Type Description nonce u64 a random number Error messages \u00b6 The error messages are structured as follow: Field Type Description code u32 predefined error code message string user friendly message References \u00b6 Bitcoin: Developer Reference - Bitcoin Wiki GitHub - bitcoin/bitcoin: Bitcoin Core integration/staging tree GitHub - paritytech/parity-bitcoin: The Parity Bitcoin client Ethereum: Wiki \u00b7 GitHub GitHub - ethereum/go-ethereum: Official Go implementation of the Ethereum protocol GitHub - paritytech/parity-ethereum: The fast, light, and robust EVM and WASM client. RChain: Documentation GitHub - rchain/rchain Mimblewimble Grin: Grin, the Tech | Simple, privacy-focused, scalable MimbleWimble chain implementation. Wiki \u00b7 GitHub GitHub - mimblewimble/grin: Minimal implementation of the MimbleWimble protocol. Exonum: Exonum Documentation GitHub - exonum/exonum: An extensible open-source framework for creating private/permissioned blockchain applications","title":"Network messages"},{"location":"protocol/network/#witnet-network-protocol","text":"Witnet network protocol is inspired in other blockchain network protocols such as Bitcoin, Ethereum and Rchain. Additionally, other blockchains such as Grin and Exonum have been taken into consideration as their reference implementations are coded in Rust.","title":"Witnet Network Protocol"},{"location":"protocol/network/#initial-considerations","text":"In order to start the network discovery process, at least one existing node on the network is required. However, in order to avoid unnecessary risks or potential attack vectors, it is always recommended to know several existing nodes extracted from different sources.","title":"Initial considerations"},{"location":"protocol/network/#peer-bootstrapping-methods","text":"The strategy for selecting the first node to connect should be random, thus it should not depend on geographical position or any other network parameter. The client discovers the IP addresses and ports of other nodes in a decentralized way, i.e. there should not be a central point of trust or failure to bootstrap the network. For example, some of the considered approaches for bootstrapping a new peer into the network could one or more of the following methods: Hard coded addresses Addresses provided as command line arguments Addresses provided from user provided text file on startup Store addresses in database and read them on startup Exchange addresses with other nodes DNS requests to receive IP addresses IRC channel where peers are advertised","title":"Peer bootstrapping methods"},{"location":"protocol/network/#constants-and-defaults","text":"Witnet constants and default values used in the network protocol.","title":"Constants and Defaults"},{"location":"protocol/network/#default-values","text":"Network Default Port mainnet 11337 testnet 21337","title":"Default Values"},{"location":"protocol/network/#witnet-versions","text":"Below the existing versions of the Witnet P2P network protocol are listed: Version Initial Release Major Changes 010 to be determined","title":"Witnet versions"},{"location":"protocol/network/#magic-numbers","text":"These constant values indicate the originating network in the message headers: Network Magic number mainnet 0x00 testnet 0xF0","title":"Magic numbers"},{"location":"protocol/network/#node-capabilities","text":"Currently, only one node capabilities is being offered by Witnet: Flag Description 0x0000000000000001 NODE_NETWORK, Witnet full node which is the default operation mode","title":"Node capabilities"},{"location":"protocol/network/#user-agents","text":"Currently, only one user agent is being developed: User Agent Description /Witnet-rust:0.1.0 Witnet node implemented in Rust and version 0.1.0","title":"User agents"},{"location":"protocol/network/#common-structures","text":"Common structures used along different Witnet network messages.","title":"Common Structures"},{"location":"protocol/network/#address-format","text":"Witnet peer addresses are defined as follows: Field Type Description ipv4 u32 IPv4 address of the peer port u16 port number in which the peer is listening Alternatively, IP addresses may be IPv6: Field Type Description ipv6 [u32; 4] IPv6 address of the peer port u16 port number in which the peer is listening","title":"Address Format"},{"location":"protocol/network/#messages","text":"The current network protocol includes the description and definition of the following messages: VERSION VERACK GET_PEERS PEERS PING PONG All of these messages include a message header identifying which message type is being sent.","title":"Messages"},{"location":"protocol/network/#message-header","text":"Inspired in other blockchains, the message header format is composed of the following fields: Field Type Description magic u16 magic value indicating message origin network command string message being sent from a predefined list of available commands payload ? message data","title":"Message Header"},{"location":"protocol/network/#handshake-version-verack","text":"The protocol to connect from a local peer (initiator) to a known remote peer, also known as \"handshake\", starts with a TCP connection to a given IP address and port. The handshake initiator, the local peer, sends a version message to the remote peer. The remote peer will analyze the information in order to evaluate if the submitting peer is compatible regarding their supported versions and capabilities. If so, the remote peer will acknowledge the version message and establish a connection by sending a verack message. The version message contains the following information: Field Type Description version u32 the Witnet p2p protocol version that the client is using timestamp u64 the current time in UTC format capabilities u64 list of flags of supported services, by default NODE_NETWORK is used sender_address addr the IP address and port of the handshake initiator peer receiver_address addr the IP address and port of the remote peer user_agent string a version showing which software is running the local peer last_epoch u32 last epoch in the local peer blockchain genesis [u32; 8] hash of the genesis block nonce u64 Node random nonce, randomly generated every time a version packet is sent (used to detect connections to self) The verack message is sent as reply to the version and it only consists of a message header with the command VERACK . Subsequently, the handshake initiator will expect a version message from the remote peer. The local peer will also acknowledge by replying with a verack message. Connection cannot be considered as establish until both verack messages have been received by both peers. After sending a version message the peers will define a timeout to wait for a response. If no response is received during this timeout (usually set to 10 seconds), the peer will be discarded from the known peers list.","title":"Handshake (VERSION, VERACK)"},{"location":"protocol/network/#peer-discovery-get_peers-peers","text":"In Witnet, a node must always establish different paths into the network by connecting to different peers, ideally randomly selected. As connections may disappear, network peers should assist others when they bootstrap. After establishing a connection with remote peers (throughout a handshake mechanism), a node may request to their remote peer to receive a list of their known \"recent\" peers. This request is initiated by sending a get_peers message to a remote peer. The receiving node will reply with a peers message with a list of peer addresses that have been seen recently active in the network. The typical assumption is that a node is likely to be active if it has sent any message during the last 90 minutes. The transmitting node will then update those IP addresses and ports into its database of available nodes. The get_peers message only consists of the message header with the command GET_PEERS . The peers message consists of the message header with the command PEERS and as payload it contains a list of known peers as: Field Type Description peers addr[] list of addresses of active known peers","title":"Peer discovery (GET_PEERS, PEERS)"},{"location":"protocol/network/#heartbeat-ping-pong","text":"As in Bitcoin, the heartbeat protocol is defined with ping and pong messages and it is defined as follows: If during the last 30 minutes a peer has no transmitted any message, it will send a heartbeat as ping message. If in the last 90 minutes no message has been received by a remote peer, the local node will assume that the connection has been closed. The ping message confirms that the connection is still valid. The pong message is sent in response to a ping message. Both contain only one field: Field Type Description nonce u64 a random number","title":"Heartbeat (PING, PONG)"},{"location":"protocol/network/#error-messages","text":"The error messages are structured as follow: Field Type Description code u32 predefined error code message string user friendly message","title":"Error messages"},{"location":"protocol/network/#references","text":"Bitcoin: Developer Reference - Bitcoin Wiki GitHub - bitcoin/bitcoin: Bitcoin Core integration/staging tree GitHub - paritytech/parity-bitcoin: The Parity Bitcoin client Ethereum: Wiki \u00b7 GitHub GitHub - ethereum/go-ethereum: Official Go implementation of the Ethereum protocol GitHub - paritytech/parity-ethereum: The fast, light, and robust EVM and WASM client. RChain: Documentation GitHub - rchain/rchain Mimblewimble Grin: Grin, the Tech | Simple, privacy-focused, scalable MimbleWimble chain implementation. Wiki \u00b7 GitHub GitHub - mimblewimble/grin: Minimal implementation of the MimbleWimble protocol. Exonum: Exonum Documentation GitHub - exonum/exonum: An extensible open-source framework for creating private/permissioned blockchain applications","title":"References"}]}
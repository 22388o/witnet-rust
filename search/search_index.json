{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Witnet-rust \u00b6 Witnet-rust is an open-source implementation of the Witnet protocol written in Rust. The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central to incentivizing the network players to abide by the protocol and make them liable for any misbehavior. Active network participants will earn wit tokens for fulfilling the data retrieval, attestation and delivery tasks coming from different smart contract platforms such as Ethereum and RChain. Witnet-rust is the first open-source implementation of the Witnet protocol and leverages the Rust programming language to achieve utmost speed, memory safety and fearless concurrency without compromising on performance. Tip See \" Why Rust? \" for a more technical overview on why we chose Rust. Get started \u00b6 Installation \u00b6 Witnet-rust is an open-source native app providing \"full node\" functionality of the Witnet Decentralized Oracle Network protocol. It is available under the GNU General Public License v3.0 . You may refer to the installation guide in order to install the app together with its dependencies. Roadmap \u00b6 Witnet-rust is an ambitious effort in its early days. We are currently working towards launching our first testnet. As you can guess from our datailed roadmap and GitHub issues , there are still a lot of missing features (and a whole lot more that would be nice to have yet not critical for our testnet launch). Contributing \u00b6 See the contributing guide to get more information on how to contribute to Rust-witnet development, and the roadmap to find out what features are coming soon.","title":"Home"},{"location":"#witnet-rust","text":"Witnet-rust is an open-source implementation of the Witnet protocol written in Rust. The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central to incentivizing the network players to abide by the protocol and make them liable for any misbehavior. Active network participants will earn wit tokens for fulfilling the data retrieval, attestation and delivery tasks coming from different smart contract platforms such as Ethereum and RChain. Witnet-rust is the first open-source implementation of the Witnet protocol and leverages the Rust programming language to achieve utmost speed, memory safety and fearless concurrency without compromising on performance. Tip See \" Why Rust? \" for a more technical overview on why we chose Rust.","title":"Witnet-rust"},{"location":"#get-started","text":"","title":"Get started"},{"location":"#installation","text":"Witnet-rust is an open-source native app providing \"full node\" functionality of the Witnet Decentralized Oracle Network protocol. It is available under the GNU General Public License v3.0 . You may refer to the installation guide in order to install the app together with its dependencies.","title":"Installation"},{"location":"#roadmap","text":"Witnet-rust is an ambitious effort in its early days. We are currently working towards launching our first testnet. As you can guess from our datailed roadmap and GitHub issues , there are still a lot of missing features (and a whole lot more that would be nice to have yet not critical for our testnet launch).","title":"Roadmap"},{"location":"#contributing","text":"See the contributing guide to get more information on how to contribute to Rust-witnet development, and the roadmap to find out what features are coming soon.","title":"Contributing"},{"location":"contributing/","text":"Contributing to Witnet-rust \u00b6 Thank you for being interested in contributing to Witnet! The following is a set of guidelines and helpful pointers for contributing to Witnet The keyword here is guidelines, not rules. As such, use your best judgement and feel free to propose changes to even this document. Code of conduct \u00b6 Everyone participating in this project is governed by the Witnet Code of Conduct . By participating, you are expected to uphold this code as well. I just have a question \u00b6 Please don't file an issue with questions. It's easier for you and for us if you go directly to our Gitter chatroom , since it will keep our repositories clean and you will get a faster response. How can I contribute? \u00b6 Find an area you can help with and do it. Open source is about collaboration and open participation. Try to make your code look like what already exists and submit a pull request. The list of issues is a good place to start, especially the ones tagged as \"good first issue\" or \"help wanted\" (but don't let that stop you from looking at others). If you're looking for additional ideas, the code includes TODO comments for minor to major improvements. Grep is your friend. Additional tests are rewarded with an immense amount of positive karma. More documentation or updates/fixes to existing documentation are also very welcome. However, if submitting a PR consisting of documentation changes only, please try to ensure that the change is significantly more substantial than one or two lines. For example, working through an install document and making changes and updates throughout as you find issues is worth a PR. For typos and other small changes, either contact one of the developers, or if you think it's a significant enough error to cause problems for other users, please feel free to open an issue. Reporting bugs \u00b6 This section guides you through submitting a bug report. This helps contributors and maintainers understand your report, reproduce the behavior, and in turn squash the bug. Before submitting a bug report, please make sure that you've searched through the issues and that there isn't already an issue describing the same issue you are having. How do I submit a good bug report? \u00b6 Bugs are tracked as GitHub issues . Explain the problem and include additional details to help maintainers reproduce the problem: Use a clear and descriptive title for the issue to identify the problem. Describe the exact steps which reproduce the problem in as many details as possible. Provide specific examples to demonstrate the steps. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use Markdown code blocks. Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior. Explain which behavior you expected to see instead and why. Post a screenshot or a dump of the developer console If the problem wasn't triggered by a specific action, describe what you were doing before the problem happened and share more information using the guidelines below. Provide more context by answering these questions: Did the problem start happening recently (e.g. after updating to a new version) or was this always a problem? If the problem started happening recently, can you reproduce the problem in an older version of Witnet-rust? What's the most recent version in which the problem doesn't happen? Can you reliably reproduce the issue? If not, provide details about how often the problem happens and under which conditions it normally happens. Include details about your configuration and environment: Which version of rustc are you using? You can get the exact version by running rustc --version --verbose in your terminal. What's your operating system and version? Suggesting enhancements \u00b6 This section guides you through submitting an enhancement suggestion, including completely new features and minor improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion. Before creating enhancement suggestions, please double check that there is not already an existing feature suggestion for your feature, as you might find out that you don't need to create one. When you are creating an enhancement suggestion, please include as many details as possible. How Do I Submit A Good Enhancement Suggestion? \u00b6 Enhancement suggestions are tracked as GitHub issues. Create an issue on that repository and provide the following information: Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Provide specific examples to demonstrate the steps. Include copy/pasteable snippets which you use in those examples, as Markdown code blocks. Describe the current behavior and explain which behavior you expected to see instead and why. Explain why this enhancement would be useful to most users and isn't something that can or should be implemented as a community package. Your First Code Contribution \u00b6 Unsure where to begin contributing? You can start by looking through these good first issue issues: Good first issue - issues which should only require a few lines of code, and a test or two. Copyright \u00b6 These guidelines are inspired by: AragonJS Contributing Guidelines , published under the Creative Commons Zero v1.0 Universal License . Grin Contributing Guide , published under the Apache License 2.0 .","title":"Contributing"},{"location":"contributing/#contributing-to-witnet-rust","text":"Thank you for being interested in contributing to Witnet! The following is a set of guidelines and helpful pointers for contributing to Witnet The keyword here is guidelines, not rules. As such, use your best judgement and feel free to propose changes to even this document.","title":"Contributing to Witnet-rust"},{"location":"contributing/#code-of-conduct","text":"Everyone participating in this project is governed by the Witnet Code of Conduct . By participating, you are expected to uphold this code as well.","title":"Code of conduct"},{"location":"contributing/#i-just-have-a-question","text":"Please don't file an issue with questions. It's easier for you and for us if you go directly to our Gitter chatroom , since it will keep our repositories clean and you will get a faster response.","title":"I just have a question"},{"location":"contributing/#how-can-i-contribute","text":"Find an area you can help with and do it. Open source is about collaboration and open participation. Try to make your code look like what already exists and submit a pull request. The list of issues is a good place to start, especially the ones tagged as \"good first issue\" or \"help wanted\" (but don't let that stop you from looking at others). If you're looking for additional ideas, the code includes TODO comments for minor to major improvements. Grep is your friend. Additional tests are rewarded with an immense amount of positive karma. More documentation or updates/fixes to existing documentation are also very welcome. However, if submitting a PR consisting of documentation changes only, please try to ensure that the change is significantly more substantial than one or two lines. For example, working through an install document and making changes and updates throughout as you find issues is worth a PR. For typos and other small changes, either contact one of the developers, or if you think it's a significant enough error to cause problems for other users, please feel free to open an issue.","title":"How can I contribute?"},{"location":"contributing/#reporting-bugs","text":"This section guides you through submitting a bug report. This helps contributors and maintainers understand your report, reproduce the behavior, and in turn squash the bug. Before submitting a bug report, please make sure that you've searched through the issues and that there isn't already an issue describing the same issue you are having.","title":"Reporting bugs"},{"location":"contributing/#how-do-i-submit-a-good-bug-report","text":"Bugs are tracked as GitHub issues . Explain the problem and include additional details to help maintainers reproduce the problem: Use a clear and descriptive title for the issue to identify the problem. Describe the exact steps which reproduce the problem in as many details as possible. Provide specific examples to demonstrate the steps. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use Markdown code blocks. Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior. Explain which behavior you expected to see instead and why. Post a screenshot or a dump of the developer console If the problem wasn't triggered by a specific action, describe what you were doing before the problem happened and share more information using the guidelines below. Provide more context by answering these questions: Did the problem start happening recently (e.g. after updating to a new version) or was this always a problem? If the problem started happening recently, can you reproduce the problem in an older version of Witnet-rust? What's the most recent version in which the problem doesn't happen? Can you reliably reproduce the issue? If not, provide details about how often the problem happens and under which conditions it normally happens. Include details about your configuration and environment: Which version of rustc are you using? You can get the exact version by running rustc --version --verbose in your terminal. What's your operating system and version?","title":"How do I submit a good bug report?"},{"location":"contributing/#suggesting-enhancements","text":"This section guides you through submitting an enhancement suggestion, including completely new features and minor improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion. Before creating enhancement suggestions, please double check that there is not already an existing feature suggestion for your feature, as you might find out that you don't need to create one. When you are creating an enhancement suggestion, please include as many details as possible.","title":"Suggesting enhancements"},{"location":"contributing/#how-do-i-submit-a-good-enhancement-suggestion","text":"Enhancement suggestions are tracked as GitHub issues. Create an issue on that repository and provide the following information: Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Provide specific examples to demonstrate the steps. Include copy/pasteable snippets which you use in those examples, as Markdown code blocks. Describe the current behavior and explain which behavior you expected to see instead and why. Explain why this enhancement would be useful to most users and isn't something that can or should be implemented as a community package.","title":"How Do I Submit A Good Enhancement Suggestion?"},{"location":"contributing/#your-first-code-contribution","text":"Unsure where to begin contributing? You can start by looking through these good first issue issues: Good first issue - issues which should only require a few lines of code, and a test or two.","title":"Your First Code Contribution"},{"location":"contributing/#copyright","text":"These guidelines are inspired by: AragonJS Contributing Guidelines , published under the Creative Commons Zero v1.0 Universal License . Grin Contributing Guide , published under the Apache License 2.0 .","title":"Copyright"},{"location":"development/","text":"Development \u00b6 Witnet-rust is build using The Rust Programming language and following rust2018 edition guide . Installing \u00b6 Install dependencies Rust 1.31 (currently on the nightly release channel) flatc FlatBuffers compiler (optional, only if recompiling schemas) mkdocs , pymdown-extensions , mkdocs-material python packages (optional, only if generating documentation) Clone the source code from github: $ git clone https://github.com/witnet/witnet-rust.git $ cd witnet-rust Use cargo to install just . $ cargo install just Run just script to install dev tools $ just install-setup Run a witnet component. Find a list of components and how to run them at CLI . $ RUST_LOG = witnet = trace cargo run server or $ just server CLI \u00b6 Synopsis \u00b6 RUST_LOG=witnet=[error | info | debug | main | trace] cargo run [server [ --address address] [--peer peer-address] [--background]] Components \u00b6 Server \u00b6 --address <address> Read server address from <address> argument. --peer <peer-address> Read address to peer from <peer-address> argument. --background Not implemented. Development Scripts \u00b6 There are some useful scripts to run with just : clippy : Run clippy style checking. docs-build : Compile docs into static files. docs-deploy : Deploy compiled docs into gh-pages branch. docs-dev : Run local documentation server at localhost:8000 fmt : Run code formatter. install-clippy . Install clippy library. install-rustfmt : Install rustfmt library. install-setup : Install dev tools. server : Run witnet server component. travis : Run travis build.","title":"Development"},{"location":"development/#development","text":"Witnet-rust is build using The Rust Programming language and following rust2018 edition guide .","title":"Development"},{"location":"development/#installing","text":"Install dependencies Rust 1.31 (currently on the nightly release channel) flatc FlatBuffers compiler (optional, only if recompiling schemas) mkdocs , pymdown-extensions , mkdocs-material python packages (optional, only if generating documentation) Clone the source code from github: $ git clone https://github.com/witnet/witnet-rust.git $ cd witnet-rust Use cargo to install just . $ cargo install just Run just script to install dev tools $ just install-setup Run a witnet component. Find a list of components and how to run them at CLI . $ RUST_LOG = witnet = trace cargo run server or $ just server","title":"Installing"},{"location":"development/#cli","text":"","title":"CLI"},{"location":"development/#synopsis","text":"RUST_LOG=witnet=[error | info | debug | main | trace] cargo run [server [ --address address] [--peer peer-address] [--background]]","title":"Synopsis"},{"location":"development/#components","text":"","title":"Components"},{"location":"development/#server","text":"--address <address> Read server address from <address> argument. --peer <peer-address> Read address to peer from <peer-address> argument. --background Not implemented.","title":"Server"},{"location":"development/#development-scripts","text":"There are some useful scripts to run with just : clippy : Run clippy style checking. docs-build : Compile docs into static files. docs-deploy : Deploy compiled docs into gh-pages branch. docs-dev : Run local documentation server at localhost:8000 fmt : Run code formatter. install-clippy . Install clippy library. install-rustfmt : Install rustfmt library. install-setup : Install dev tools. server : Run witnet server component. travis : Run travis build.","title":"Development Scripts"},{"location":"architecture/storage/","text":"Persistent Storage \u00b6 From the perspective of software architecture, persistent storage is one of the key elements to maintaining a distributed block chain. Its role is allowing nodes in the network to preserve important data structures that need to be kept over time for trustless validation of new chain objects. Namely, those structures are: The UTXO set Data requests Transactions Blocks Generic Storage Trait \u00b6 Witnet-rust features a generic Storage Rust trait ( storage.rs ) that exposes a key/value API with the elemental CRUD methods (create, read, update, delete) while abstracting away from specific storage backend implementations. pub trait Storage < ConnData , Key , Value > { /** **/ } The meaning of the generic types is the following: Generic type Description ConnData Type of the data needed by the constructor for creating a connection to the storage backend. Key Type of the keys used to identify the records in the storage. Value Type of the values in the storage. As of PR #21 , Witnet-rust incorporates implementations for the following storage backends: rocks.rs : persists data into the local file system using the performant RocksDB engine. in_memory.rs : keeps data in a HashMap that lives in the memory heap. Warning In-memory storage is implemented only for the sake of testing the Storage trait. It is obviously not a viable persistence solution as data is totally wiped as soon as references to the storage go out of scope or the app dies. Instantiation \u00b6 All implementors of the Storage trait can be instantiated with the witnet_storage::storage::new() constructor, which must be used as a static method. Signature fn new ( connection_data : ConnData ) -> Result < Box < Self >> ; Tip Please note that the witnet_storage::storage::new() method wraps the return type into a Box . This is to ensure the value is allocated into the heap and to allow a reference to it (the Box itself) to outlive the constructor. Example use witnet_storage :: backends :: in_memory :: InMemoryStorage ; let storage : & InMemoryStorage = InMemoryStorage :: new (). unwrap (); Creating and updating records with the put() Method \u00b6 The witnet_storage::storage::put() method allows creating or replacing a value in the storage under a certain key. Signature fn put ( & mut self , key : Key , value : Value ) -> Result < () > ; Example // Put value \"bar\" into key \"foo\" storage . put ( b\"foo\" , b\"bar\" . to_vec ()) ? ; // Update value of \"foo\" to be \"beer\" storage . put ( b\"foo\" , b\"beer\" . to_vec ()) ? ; Getting records with the get() method \u00b6 The witnet_storage::storage::get() method allows reading the value in the storage under a certain key. Signature fn get ( & self , key : Key ) -> Result < Option < Value >> ; Example match storage . get ( b\"foo\" ) { Ok ( Some ( value )) => , // Found a value Ok ( None ) => , // The key didn't exist Err ( error ) => // Error while reading } Deleting records with the delete() method \u00b6 The witnet_storage::storage::delete() method allows deleting a record in the storage given its key. Signature fn delete ( & mut self , key : Key ) -> Result < () > ; Example storage . delete ( b\"foo\" ) ? ; RocksDB Storage Backend \u00b6 The RocksDB storage backend ( rocks.rs ) is one of the bundled storage backends in Witnet-rust. It implements all the methods of the Storage trait for the RocksStorage struct: /// Data structure for the RocksDB storage whose only member is a /// rocksdb::DB object. pub struct RocksStorage { db : DB } The actual implementor looks like this (function bodies and some lifetime annotations have been omitted for brevity): // Implement the Storage generic trait for the RocksStorage storage // data structure. impl Storage <& str , & [ u8 ], Vec < u8 >> for RocksStorage { fn new ( path : & str ) -> Result < Box < Self >> ; fn put ( & mut self , key : & [ u8 ], value : Vec < u8 > ) -> Result < () > ; fn get ( & self , key : & [ u8 ]) -> Result < Option < Vec < u8 >>> ; fn delete ( & mut self , key : & [ u8 ]) -> Result < () > ; } These are the specific types for this implementor: Generic type Specific type ConnData &str Key &[u8] Value Vec<u8> The full source code of the Storage implementor for RocksStorage can be found at rocks.rs .","title":"Persistent Storage"},{"location":"architecture/storage/#persistent-storage","text":"From the perspective of software architecture, persistent storage is one of the key elements to maintaining a distributed block chain. Its role is allowing nodes in the network to preserve important data structures that need to be kept over time for trustless validation of new chain objects. Namely, those structures are: The UTXO set Data requests Transactions Blocks","title":"Persistent Storage"},{"location":"architecture/storage/#generic-storage-trait","text":"Witnet-rust features a generic Storage Rust trait ( storage.rs ) that exposes a key/value API with the elemental CRUD methods (create, read, update, delete) while abstracting away from specific storage backend implementations. pub trait Storage < ConnData , Key , Value > { /** **/ } The meaning of the generic types is the following: Generic type Description ConnData Type of the data needed by the constructor for creating a connection to the storage backend. Key Type of the keys used to identify the records in the storage. Value Type of the values in the storage. As of PR #21 , Witnet-rust incorporates implementations for the following storage backends: rocks.rs : persists data into the local file system using the performant RocksDB engine. in_memory.rs : keeps data in a HashMap that lives in the memory heap. Warning In-memory storage is implemented only for the sake of testing the Storage trait. It is obviously not a viable persistence solution as data is totally wiped as soon as references to the storage go out of scope or the app dies.","title":"Generic Storage Trait"},{"location":"architecture/storage/#instantiation","text":"All implementors of the Storage trait can be instantiated with the witnet_storage::storage::new() constructor, which must be used as a static method. Signature fn new ( connection_data : ConnData ) -> Result < Box < Self >> ; Tip Please note that the witnet_storage::storage::new() method wraps the return type into a Box . This is to ensure the value is allocated into the heap and to allow a reference to it (the Box itself) to outlive the constructor. Example use witnet_storage :: backends :: in_memory :: InMemoryStorage ; let storage : & InMemoryStorage = InMemoryStorage :: new (). unwrap ();","title":"Instantiation"},{"location":"architecture/storage/#creating-and-updating-records-with-the-put-method","text":"The witnet_storage::storage::put() method allows creating or replacing a value in the storage under a certain key. Signature fn put ( & mut self , key : Key , value : Value ) -> Result < () > ; Example // Put value \"bar\" into key \"foo\" storage . put ( b\"foo\" , b\"bar\" . to_vec ()) ? ; // Update value of \"foo\" to be \"beer\" storage . put ( b\"foo\" , b\"beer\" . to_vec ()) ? ;","title":"Creating and updating records with the put() Method"},{"location":"architecture/storage/#getting-records-with-the-get-method","text":"The witnet_storage::storage::get() method allows reading the value in the storage under a certain key. Signature fn get ( & self , key : Key ) -> Result < Option < Value >> ; Example match storage . get ( b\"foo\" ) { Ok ( Some ( value )) => , // Found a value Ok ( None ) => , // The key didn't exist Err ( error ) => // Error while reading }","title":"Getting records with the get() method"},{"location":"architecture/storage/#deleting-records-with-the-delete-method","text":"The witnet_storage::storage::delete() method allows deleting a record in the storage given its key. Signature fn delete ( & mut self , key : Key ) -> Result < () > ; Example storage . delete ( b\"foo\" ) ? ;","title":"Deleting records with the delete() method"},{"location":"architecture/storage/#rocksdb-storage-backend","text":"The RocksDB storage backend ( rocks.rs ) is one of the bundled storage backends in Witnet-rust. It implements all the methods of the Storage trait for the RocksStorage struct: /// Data structure for the RocksDB storage whose only member is a /// rocksdb::DB object. pub struct RocksStorage { db : DB } The actual implementor looks like this (function bodies and some lifetime annotations have been omitted for brevity): // Implement the Storage generic trait for the RocksStorage storage // data structure. impl Storage <& str , & [ u8 ], Vec < u8 >> for RocksStorage { fn new ( path : & str ) -> Result < Box < Self >> ; fn put ( & mut self , key : & [ u8 ], value : Vec < u8 > ) -> Result < () > ; fn get ( & self , key : & [ u8 ]) -> Result < Option < Vec < u8 >>> ; fn delete ( & mut self , key : & [ u8 ]) -> Result < () > ; } These are the specific types for this implementor: Generic type Specific type ConnData &str Key &[u8] Value Vec<u8> The full source code of the Storage implementor for RocksStorage can be found at rocks.rs .","title":"RocksDB Storage Backend"},{"location":"architecture/managers/peers-manager/","text":"Peers Manager \u00b6 The peers manager is the actor that encapsulates the logic of the peers library, defined under the subcrate witnet_p2p . The library allows to manage a list of peers known to the Witnet node. There can only be one peers manager actor per system, and it must be registered into the system registry. This way, any other actor can get the address of the peers manager and send messages to it. State \u00b6 The state of the actor is an instance of the Peers library, which contains a list of peers known to the Witnet node. #[derive(Default)] pub struct PeersManager { /// Known peers peers : Peers , } The PeersManager actor requires the implementation of the Default trait (as well as Supervised and SystemService traits) to become a service that can be registered in the system registry. Actor creation and registration \u00b6 The creation of the peers manager actor is performed directly by the main process: let peers_manager_addr = PeersManager :: default (). start (); The default() method initializes the peers manager and its underlying peers data structure. Once the peers manager actor is started, the main process registers the actor into the system registry: System :: current (). registry (). set ( storage_manager_addr ); API \u00b6 Incoming: Others -> Peers Manager \u00b6 These are the messages supported by the storage manager handlers: Message Input type Output type Description GetPeer () PeersResult<Option<SocketAddr>> Get random peer AddPeer address : SocketAddr PeersResult<Option<SocketAddr>> Add peer to list RemovePeer address : SocketAddr PeersResult<Option<SocketAddr>> Remove peer from list The handling of these messages is basically just calling the corresponding methods from the Peers library that is implemented by peers.rs . For example, the handler of the AddPeer message would be implemented as: /// Handler for Add peer message. impl Handler < AddPeer > for PeersManager { type Result = PeersResult < Option < SocketAddr >> ; fn handle ( & mut self , msg : AddPeer , _ : & mut Context < Self > ) -> Self :: Result { // Insert address debug ! ( \"Add peer handle for address {}\" , msg . address ); self . peers . add ( msg . address ) } } Being the PeersManager such a simple actor, there are no errors that can arise due to its own logic and thus, returning a PeersResult library generic error may be the right thing to do. The way other actors will communicate with the storage manager is: Get the address of the manager from the registry: // Get peers manager address let peers_manager_addr = System :: current (). registry (). get :: < PeersManager > (); Use any of the sending methods provided by the address ( do_send() , try_send() , send() ) to send a message to the actor: // Example peers_manager_addr . send ( AddPeer { address }) . into_actor ( self ) . then ( | res , _act , _ctx | { match res { Ok ( res ) => { // Process PeersResult println ! ( \"Add peer {:?} returned {:?}\" , address , res ) }, _ => println ! ( \"Something went really wrong in the actors message passing\" ) }; actix :: fut :: ok (()) }) . wait ( ctx ); [WIP] Outgoing: Storage manager -> Others \u00b6 Currently, the peers manager is quite a simple wrapper over the peers library and it does not need to start a communication with other actors in order to perform its functions. However, it is foreseen that in the future, the peers manager will call the Storage Manager in order to store a list of known peers. This list might be used for initialization purposes of a future execution of the Witnet node. Further information \u00b6 The full source code of the PeersManager can be found at peers_manager.rs .","title":"Peers Manager"},{"location":"architecture/managers/peers-manager/#peers-manager","text":"The peers manager is the actor that encapsulates the logic of the peers library, defined under the subcrate witnet_p2p . The library allows to manage a list of peers known to the Witnet node. There can only be one peers manager actor per system, and it must be registered into the system registry. This way, any other actor can get the address of the peers manager and send messages to it.","title":"Peers Manager"},{"location":"architecture/managers/peers-manager/#state","text":"The state of the actor is an instance of the Peers library, which contains a list of peers known to the Witnet node. #[derive(Default)] pub struct PeersManager { /// Known peers peers : Peers , } The PeersManager actor requires the implementation of the Default trait (as well as Supervised and SystemService traits) to become a service that can be registered in the system registry.","title":"State"},{"location":"architecture/managers/peers-manager/#actor-creation-and-registration","text":"The creation of the peers manager actor is performed directly by the main process: let peers_manager_addr = PeersManager :: default (). start (); The default() method initializes the peers manager and its underlying peers data structure. Once the peers manager actor is started, the main process registers the actor into the system registry: System :: current (). registry (). set ( storage_manager_addr );","title":"Actor creation and registration"},{"location":"architecture/managers/peers-manager/#api","text":"","title":"API"},{"location":"architecture/managers/peers-manager/#incoming-others-peers-manager","text":"These are the messages supported by the storage manager handlers: Message Input type Output type Description GetPeer () PeersResult<Option<SocketAddr>> Get random peer AddPeer address : SocketAddr PeersResult<Option<SocketAddr>> Add peer to list RemovePeer address : SocketAddr PeersResult<Option<SocketAddr>> Remove peer from list The handling of these messages is basically just calling the corresponding methods from the Peers library that is implemented by peers.rs . For example, the handler of the AddPeer message would be implemented as: /// Handler for Add peer message. impl Handler < AddPeer > for PeersManager { type Result = PeersResult < Option < SocketAddr >> ; fn handle ( & mut self , msg : AddPeer , _ : & mut Context < Self > ) -> Self :: Result { // Insert address debug ! ( \"Add peer handle for address {}\" , msg . address ); self . peers . add ( msg . address ) } } Being the PeersManager such a simple actor, there are no errors that can arise due to its own logic and thus, returning a PeersResult library generic error may be the right thing to do. The way other actors will communicate with the storage manager is: Get the address of the manager from the registry: // Get peers manager address let peers_manager_addr = System :: current (). registry (). get :: < PeersManager > (); Use any of the sending methods provided by the address ( do_send() , try_send() , send() ) to send a message to the actor: // Example peers_manager_addr . send ( AddPeer { address }) . into_actor ( self ) . then ( | res , _act , _ctx | { match res { Ok ( res ) => { // Process PeersResult println ! ( \"Add peer {:?} returned {:?}\" , address , res ) }, _ => println ! ( \"Something went really wrong in the actors message passing\" ) }; actix :: fut :: ok (()) }) . wait ( ctx );","title":"Incoming: Others -&gt; Peers Manager"},{"location":"architecture/managers/peers-manager/#wip-outgoing-storage-manager-others","text":"Currently, the peers manager is quite a simple wrapper over the peers library and it does not need to start a communication with other actors in order to perform its functions. However, it is foreseen that in the future, the peers manager will call the Storage Manager in order to store a list of known peers. This list might be used for initialization purposes of a future execution of the Witnet node.","title":"[WIP] Outgoing: Storage manager -&gt; Others"},{"location":"architecture/managers/peers-manager/#further-information","text":"The full source code of the PeersManager can be found at peers_manager.rs .","title":"Further information"},{"location":"architecture/managers/storage-manager/","text":"Storage Manager \u00b6 The storage manager is the actor that encapsulates the logic of the persistent storage library. There can only be one storage manager actor per system, and it must be registered into the system registry. This way, any other actor can get the address of the storage manager and send messages to it. State \u00b6 The state of the actor is an instance of the RocksStorage backend encapsulated in an option. /// Storage manager actor #[derive(Default)] pub struct StorageManager { /// DB storage storage : Option < RocksStorage > , } The StorageManager actor requires the implementation of the Default trait (as well as Supervised and SystemService traits) to become a service that can be registered in the system registry. The connection to the database is an Option to handle failures in the creation of the connection to the database. Actor creation and registration \u00b6 The creation of the storage manager actor is performed directly by the main process: let storage_manager_addr = StorageManager :: new ( & db_root ). start (); The new() method tries to connect to the database specified in the path given as argument. If the connection is not possible for any reason, the storage in the state will be None . Otherwise, the state will contain the handle to the database for future use. Once the storage manager actor is started, the main process registers the actor into the system registry: System :: current (). registry (). set ( storage_manager_addr ); API \u00b6 Incoming messages: Others -> Storage manager \u00b6 These are the messages supported by the storage manager handlers: Message Input type Output type Description Get &'static [u8] StorageResult<Option<Vec<u8>>> Wrapper to RocksStorage get() method Put &'static [u8] , Vec<u8> StorageResult<()> Wrapper to RocksStorage put() method Delete &'static [u8] StorageResult<()> Wrapper to RocksStorage delete() method The handling of these messages is basically just calling the corresponding method from the Storage trait that is implemented by RocksStorage . For example, the handler of the Get message would be implemented as: /// Handler for Get message. impl Handler < Get > for StorageManager { type Result = StorageResult < Option < Vec < u8 >>> ; fn handle ( & mut self , msg : Get , _ : & mut Context < Self > ) -> Self :: Result { self . storage . as_ref (). unwrap (). get ( msg . key ) } } Being the StorageManager such a simple actor, there are no errors that can arise due to its own logic and thus, returning the StorageResult library generic error may be the right thing to do. The way other actors will communicate with the storage manager is: Get the address of the storage manager from the registry: // Get storage manager address let storage_manager_addr = System :: current (). registry (). get :: < StorageManager > (); Use any of the sending methods provided by the address ( do_send() , try_send() , send() ) to send a message to the actor: // Example storage_manager_addr . send ( Get { key : PEERS_KEY }) . into_actor ( self ) . then ( | res , _act , _ctx | { match res { Ok ( res ) => { // Process StorageResult match res { Ok ( opt ) => { // Process Option<Vec<u8>> match opt { Some ( vec ) => println ! ( \"PEERS_KEY found in storage, value: {:?}\" , vec ), None => println ! ( \"PEERS_KEY not found in storage\" ) }; }, Err ( _ ) => println ! ( \"Something went wrong when accessing the storage\" ) }; }, _ => println ! ( \"Something went really wrong in the actors message passing\" ) }; actix :: fut :: ok (()) }) . wait ( ctx ); Warning The values used as keys for the storage need to be defined with the static lifetime. Literals can be a good choice for this purpose: pub static PEERS_KEY : & 'static [ u8 ] = b\"peers\" ; Outgoing messages: Storage manager -> Others \u00b6 The storage manager is quite a simple wrapper over the storage library and it does not need to start a communication with other actors in order to perform its functions. Further information \u00b6 The full source code of the StorageManager can be found at storage_manager.rs .","title":"Storage Manager"},{"location":"architecture/managers/storage-manager/#storage-manager","text":"The storage manager is the actor that encapsulates the logic of the persistent storage library. There can only be one storage manager actor per system, and it must be registered into the system registry. This way, any other actor can get the address of the storage manager and send messages to it.","title":"Storage Manager"},{"location":"architecture/managers/storage-manager/#state","text":"The state of the actor is an instance of the RocksStorage backend encapsulated in an option. /// Storage manager actor #[derive(Default)] pub struct StorageManager { /// DB storage storage : Option < RocksStorage > , } The StorageManager actor requires the implementation of the Default trait (as well as Supervised and SystemService traits) to become a service that can be registered in the system registry. The connection to the database is an Option to handle failures in the creation of the connection to the database.","title":"State"},{"location":"architecture/managers/storage-manager/#actor-creation-and-registration","text":"The creation of the storage manager actor is performed directly by the main process: let storage_manager_addr = StorageManager :: new ( & db_root ). start (); The new() method tries to connect to the database specified in the path given as argument. If the connection is not possible for any reason, the storage in the state will be None . Otherwise, the state will contain the handle to the database for future use. Once the storage manager actor is started, the main process registers the actor into the system registry: System :: current (). registry (). set ( storage_manager_addr );","title":"Actor creation and registration"},{"location":"architecture/managers/storage-manager/#api","text":"","title":"API"},{"location":"architecture/managers/storage-manager/#incoming-messages-others-storage-manager","text":"These are the messages supported by the storage manager handlers: Message Input type Output type Description Get &'static [u8] StorageResult<Option<Vec<u8>>> Wrapper to RocksStorage get() method Put &'static [u8] , Vec<u8> StorageResult<()> Wrapper to RocksStorage put() method Delete &'static [u8] StorageResult<()> Wrapper to RocksStorage delete() method The handling of these messages is basically just calling the corresponding method from the Storage trait that is implemented by RocksStorage . For example, the handler of the Get message would be implemented as: /// Handler for Get message. impl Handler < Get > for StorageManager { type Result = StorageResult < Option < Vec < u8 >>> ; fn handle ( & mut self , msg : Get , _ : & mut Context < Self > ) -> Self :: Result { self . storage . as_ref (). unwrap (). get ( msg . key ) } } Being the StorageManager such a simple actor, there are no errors that can arise due to its own logic and thus, returning the StorageResult library generic error may be the right thing to do. The way other actors will communicate with the storage manager is: Get the address of the storage manager from the registry: // Get storage manager address let storage_manager_addr = System :: current (). registry (). get :: < StorageManager > (); Use any of the sending methods provided by the address ( do_send() , try_send() , send() ) to send a message to the actor: // Example storage_manager_addr . send ( Get { key : PEERS_KEY }) . into_actor ( self ) . then ( | res , _act , _ctx | { match res { Ok ( res ) => { // Process StorageResult match res { Ok ( opt ) => { // Process Option<Vec<u8>> match opt { Some ( vec ) => println ! ( \"PEERS_KEY found in storage, value: {:?}\" , vec ), None => println ! ( \"PEERS_KEY not found in storage\" ) }; }, Err ( _ ) => println ! ( \"Something went wrong when accessing the storage\" ) }; }, _ => println ! ( \"Something went really wrong in the actors message passing\" ) }; actix :: fut :: ok (()) }) . wait ( ctx ); Warning The values used as keys for the storage need to be defined with the static lifetime. Literals can be a good choice for this purpose: pub static PEERS_KEY : & 'static [ u8 ] = b\"peers\" ;","title":"Incoming messages: Others -&gt; Storage manager"},{"location":"architecture/managers/storage-manager/#outgoing-messages-storage-manager-others","text":"The storage manager is quite a simple wrapper over the storage library and it does not need to start a communication with other actors in order to perform its functions.","title":"Outgoing messages: Storage manager -&gt; Others"},{"location":"architecture/managers/storage-manager/#further-information","text":"The full source code of the StorageManager can be found at storage_manager.rs .","title":"Further information"},{"location":"get-started/what-is-witnet/","text":"What is Witnet \u00b6 The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. Wait, what? Ok, lets go one step at a time. Smart Contracts Are Not What You Think \u00b6 Over the last years, blockchain technology has promised to revolutionize business by allowing creation of \"smart contracts\" that, unlike paper contracts, are impossible to breach. Actually, those smart contracts are nothing more than small programs that can be run in a trustless manner. That is: once they are created, no one can stop them from doing exactly what they were created for. They just obey their own source code, and censorship is just impossible. This is a really powerful idea. If you can write a smart contract that: implements the logic of an agreement, and can execute the clauses of the contract on its own (like paying Alice or Bob depending on the outcome of some event), then you have a contract that is capable of enforcing itself and leaves no room for contestation. Boom . Blockchain Oracles, And Their Problem \u00b6 Given that smart contracts need to be completely deterministic 1 , they do not support input of data from non-deterministic sources such as APIs or websites. As a result, smart contracts are mostly isolated from the rest of the Internet, which dramatically reduces their transformative potential. At the end of the day, the output of a program does not depend solely on its source code, but also on the input data it operates upon. Of course, as the creator of a smart contract, you can create a method that allows you and only you to act as an \"oracle\" by introducing information from the outside at will. But you would be completely breaking the trustless nature of a smart contract. If trust is put in a single entity, there you have a single point of failure that can easily be hacked or corrupted. Smart contracts connected to the real world will not be completely trustless and will not release their full potential until we have ways to feed them information trustlessly. This is often called \"the oracle problem\" . The Solution: A Decentralized Oracle Network \u00b6 The Witnet protocol aims to create an overlay network that connects smart contracts to any online data source. Sport results, stock prices, weather forecasts or even other blockchains can be easily queried (preferably through APIs). The protocol describes a distributed network of peer nodes\u2014which we fondly call witnesses \u2014who earn Wit tokens as a reward for retrieving web data and reporting it directly to the smart contracts. The bottom line is that a considerable number of randomly selected, anonymous peers retrieving information from one or more sources can converge into a single truth about the data they retrieved if a majority of them are incentivized to report the retrieved data honestly and they apply a common consensus algorithm that resolves inconsistencies. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central to incentivizing the network players to abide by the protocol and make them liable for any misbehavior. Witnesses are also in charge of validating transactions in the network and bundling them into blocks that get appended to the blockchain periodically. The process by which witnesses retrieve, attest and deliver data in behalf of the smart contracts is in some way similar to mining in other blockchains. However, fulfilling these tasks and collecting the rewards is not that expensive in terms of computation. The protocol has been conceived to ensure utmost decentralization and fairnes, so each witness' weight in the network is not aligned to their computing power. Instead, the probability for every witness to be assigned tasks or mine new blocks is directly proportional to their past performance in terms of honesty: their reputation. Tip Of course, the so-called miners are not actual human beings sitting in front of a computer, fulfilling assignments coming from an Internet overlord that commands them to use their web browser to navigate to a certain website and take a snapshot or copy some text that they must report. Indeed, the miners are just computers running a software (Witnet-rust) that automatically receive and execute a series of tasks without the owner of the computer having to actively do anything else than installing it. 100% Truth, 0% Trust \u00b6 Data retrieved, attested and delivered using the Witnet protocol is reliable not because of authority but because it comes from anonymous nodes who are incentivized to remain honest and to compete for rewards. In addition, integrity of this data is guaranteed by a consensus algorithm that detects fraudsters, who are immediately punished. The progressive reputation protocol plays a central role in maintaining every participant active and honest by creating short, middle and long term incentives for them to abide by the protocol and not to tamper with the data they broker. Info Please note that Witnet's aim is not spotting fake data, but guaranteeing a 1:1 match between what is published online\u2014regardless of its truthness\u2014and the data that is eventually delivered the smart contracts. Who Is Behind Witnet \u00b6 Witnet is an open source project originally devised by Stampery , the leaders of blockchain-powered data certification. The protocol is now being developed by Witnet Foundation in collaboration with a community of independent contributors. Ever since Stampery was founded in 2014, they have been on a mission: replacing blind trust with mathematical proof. Witnet is the next step towards this goal. Stampery is backed by top venture capital funds and angel investors, including Tim Draper and Blockchain Capital. The Stampery team has also been involved in the development of Aragon , Trailbot , Mongoaudit and Loqui IM . Otherwise, the contracts could have totally different output values when executed across all the nodes maintaining the blockchain, therefore causing inconsistencies that would lead to breaking the network consensus. \u21a9","title":"What is Witnet"},{"location":"get-started/what-is-witnet/#what-is-witnet","text":"The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. Wait, what? Ok, lets go one step at a time.","title":"What is Witnet"},{"location":"get-started/what-is-witnet/#smart-contracts-are-not-what-you-think","text":"Over the last years, blockchain technology has promised to revolutionize business by allowing creation of \"smart contracts\" that, unlike paper contracts, are impossible to breach. Actually, those smart contracts are nothing more than small programs that can be run in a trustless manner. That is: once they are created, no one can stop them from doing exactly what they were created for. They just obey their own source code, and censorship is just impossible. This is a really powerful idea. If you can write a smart contract that: implements the logic of an agreement, and can execute the clauses of the contract on its own (like paying Alice or Bob depending on the outcome of some event), then you have a contract that is capable of enforcing itself and leaves no room for contestation. Boom .","title":"Smart Contracts Are Not What You Think"},{"location":"get-started/what-is-witnet/#blockchain-oracles-and-their-problem","text":"Given that smart contracts need to be completely deterministic 1 , they do not support input of data from non-deterministic sources such as APIs or websites. As a result, smart contracts are mostly isolated from the rest of the Internet, which dramatically reduces their transformative potential. At the end of the day, the output of a program does not depend solely on its source code, but also on the input data it operates upon. Of course, as the creator of a smart contract, you can create a method that allows you and only you to act as an \"oracle\" by introducing information from the outside at will. But you would be completely breaking the trustless nature of a smart contract. If trust is put in a single entity, there you have a single point of failure that can easily be hacked or corrupted. Smart contracts connected to the real world will not be completely trustless and will not release their full potential until we have ways to feed them information trustlessly. This is often called \"the oracle problem\" .","title":"Blockchain Oracles, And Their Problem"},{"location":"get-started/what-is-witnet/#the-solution-a-decentralized-oracle-network","text":"The Witnet protocol aims to create an overlay network that connects smart contracts to any online data source. Sport results, stock prices, weather forecasts or even other blockchains can be easily queried (preferably through APIs). The protocol describes a distributed network of peer nodes\u2014which we fondly call witnesses \u2014who earn Wit tokens as a reward for retrieving web data and reporting it directly to the smart contracts. The bottom line is that a considerable number of randomly selected, anonymous peers retrieving information from one or more sources can converge into a single truth about the data they retrieved if a majority of them are incentivized to report the retrieved data honestly and they apply a common consensus algorithm that resolves inconsistencies. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central to incentivizing the network players to abide by the protocol and make them liable for any misbehavior. Witnesses are also in charge of validating transactions in the network and bundling them into blocks that get appended to the blockchain periodically. The process by which witnesses retrieve, attest and deliver data in behalf of the smart contracts is in some way similar to mining in other blockchains. However, fulfilling these tasks and collecting the rewards is not that expensive in terms of computation. The protocol has been conceived to ensure utmost decentralization and fairnes, so each witness' weight in the network is not aligned to their computing power. Instead, the probability for every witness to be assigned tasks or mine new blocks is directly proportional to their past performance in terms of honesty: their reputation. Tip Of course, the so-called miners are not actual human beings sitting in front of a computer, fulfilling assignments coming from an Internet overlord that commands them to use their web browser to navigate to a certain website and take a snapshot or copy some text that they must report. Indeed, the miners are just computers running a software (Witnet-rust) that automatically receive and execute a series of tasks without the owner of the computer having to actively do anything else than installing it.","title":"The Solution: A Decentralized Oracle Network"},{"location":"get-started/what-is-witnet/#100-truth-0-trust","text":"Data retrieved, attested and delivered using the Witnet protocol is reliable not because of authority but because it comes from anonymous nodes who are incentivized to remain honest and to compete for rewards. In addition, integrity of this data is guaranteed by a consensus algorithm that detects fraudsters, who are immediately punished. The progressive reputation protocol plays a central role in maintaining every participant active and honest by creating short, middle and long term incentives for them to abide by the protocol and not to tamper with the data they broker. Info Please note that Witnet's aim is not spotting fake data, but guaranteeing a 1:1 match between what is published online\u2014regardless of its truthness\u2014and the data that is eventually delivered the smart contracts.","title":"100% Truth, 0% Trust"},{"location":"get-started/what-is-witnet/#who-is-behind-witnet","text":"Witnet is an open source project originally devised by Stampery , the leaders of blockchain-powered data certification. The protocol is now being developed by Witnet Foundation in collaboration with a community of independent contributors. Ever since Stampery was founded in 2014, they have been on a mission: replacing blind trust with mathematical proof. Witnet is the next step towards this goal. Stampery is backed by top venture capital funds and angel investors, including Tim Draper and Blockchain Capital. The Stampery team has also been involved in the development of Aragon , Trailbot , Mongoaudit and Loqui IM . Otherwise, the contracts could have totally different output values when executed across all the nodes maintaining the blockchain, therefore causing inconsistencies that would lead to breaking the network consensus. \u21a9","title":"Who Is Behind Witnet"},{"location":"get-started/why-rust/","text":"Why Rust? \u00b6 Having its own underlying blockchain, Witnet requires code that is as fast as C or C++ but memory safe to prevent security vulnerabilities. At the same time, we want to produce concurrent code that can take advantage of modern hardware. After analyzing the possible languages to use, we found that Rust is a fast, memory safe and highly concurrent language which allows for writing complex multithreaded code without race conditions or dangling pointers. It allows fearless concurrency without compromising on performance. Having an undeniable influence from functional languages like ML or Haskell, Rust is very expressive yet it uses high level abstractions. This makes it easy to write correct and readable code, which in turn translates into faster and more productive development. Rust is statically typed but it sports a really nice type inferer which makes code succinct and readable. The absence of a garbage collector and low runtime requirements makes it easy to embed Rust code inside other languages like Python, Ruby or Nodejs. This is fundamental for building the bridges between Witnet and other blockchains as well as with the headless browser that will allow Witnet to perform web content retrievals. The Rust compiler is simply awesome, offering the most helpful messages we have seen in a compiler. It also has incremental compilation, which helps developers save their valuable time. No more reinventing the wheel. Unlike C or C++, Rust has a package manager\u200a\u2014\u200aa tool called cargo. Besides managing the dependencies of the project, cargo gives you the option to build, run, test, generate documentation and publish your own package to a community driven package repository. Metaprogramming. Rust macros allow for reusing code in a concise, well-abstracted way with a powerful compile-time correctness checking. And last but not least, Rust has an ever-welcoming community that is always willing to help and is currently growing at a very healthy pace. In addition, it is currently in a stage in which the ecosystem is mature enough so that you d Summing up, here are the 8 reasons why Witnet will make the most of Rust: Performance Memory safety Concurrency Influence from functional languages Statically typed with type inference Awesome compiler and tooling Metaprogramming Thriving community Tip By the way, do you love Rust and want to join one of the most exciting projects using it in the blockchain space? We\u2019re hiring! See our current open positions on AngelList .","title":"Why Rust?"},{"location":"get-started/why-rust/#why-rust","text":"Having its own underlying blockchain, Witnet requires code that is as fast as C or C++ but memory safe to prevent security vulnerabilities. At the same time, we want to produce concurrent code that can take advantage of modern hardware. After analyzing the possible languages to use, we found that Rust is a fast, memory safe and highly concurrent language which allows for writing complex multithreaded code without race conditions or dangling pointers. It allows fearless concurrency without compromising on performance. Having an undeniable influence from functional languages like ML or Haskell, Rust is very expressive yet it uses high level abstractions. This makes it easy to write correct and readable code, which in turn translates into faster and more productive development. Rust is statically typed but it sports a really nice type inferer which makes code succinct and readable. The absence of a garbage collector and low runtime requirements makes it easy to embed Rust code inside other languages like Python, Ruby or Nodejs. This is fundamental for building the bridges between Witnet and other blockchains as well as with the headless browser that will allow Witnet to perform web content retrievals. The Rust compiler is simply awesome, offering the most helpful messages we have seen in a compiler. It also has incremental compilation, which helps developers save their valuable time. No more reinventing the wheel. Unlike C or C++, Rust has a package manager\u200a\u2014\u200aa tool called cargo. Besides managing the dependencies of the project, cargo gives you the option to build, run, test, generate documentation and publish your own package to a community driven package repository. Metaprogramming. Rust macros allow for reusing code in a concise, well-abstracted way with a powerful compile-time correctness checking. And last but not least, Rust has an ever-welcoming community that is always willing to help and is currently growing at a very healthy pace. In addition, it is currently in a stage in which the ecosystem is mature enough so that you d Summing up, here are the 8 reasons why Witnet will make the most of Rust: Performance Memory safety Concurrency Influence from functional languages Statically typed with type inference Awesome compiler and tooling Metaprogramming Thriving community Tip By the way, do you love Rust and want to join one of the most exciting projects using it in the blockchain space? We\u2019re hiring! See our current open positions on AngelList .","title":"Why Rust?"},{"location":"protocol/network/","text":"Witnet Network Protocol \u00b6 Witnet network protocol is inspired in other blockchain network protocols such as Bitcoin, Ethereum and Rchain. Additionally, other blockchains such as Grin and Exonum have been taken into consideration as their reference implementations are coded in Rust. Initial considerations \u00b6 In order to start the network discovery process, at least one existing node on the network is required. However, in order to avoid unnecessary risks or potential attack vectors, it is always recommended to know several existing nodes extracted from different sources. Peer bootstrapping methods \u00b6 The strategy for selecting the first node to connect should be random, thus it should not depend on geographical position or any other network parameter. The client discovers the IP addresses and ports of other nodes in a decentralized way, i.e. there should not be a central point of trust or failure to bootstrap the network. For example, some of the considered approaches for bootstrapping a new peer into the network could one or more of the following methods: Hard coded addresses Addresses provided as command line arguments Addresses provided from user provided text file on startup Store addresses in database and read them on startup Exchange addresses with other nodes DNS requests to receive IP addresses IRC channel where peers are advertised Constants and Defaults \u00b6 Witnet constants and default values used in the network protocol. Default Values \u00b6 Network Default Port mainnet 11337 testnet 21337 Witnet versions \u00b6 Below the existing versions of the Witnet P2P network protocol are listed: Version Initial Release Major Changes 010 to be determined Magic numbers \u00b6 These constant values indicate the originating network in the message headers: Network Magic number mainnet 0x00 testnet 0xF0 Node capabilities \u00b6 Currently, only one node capabilities is being offered by Witnet: Flag Description 0x0000000000000001 NODE_NETWORK, Witnet full node which is the default operation mode User agents \u00b6 Currently, only one user agent is being developed: User Agent Description /Witnet-rust:0.1.0 Witnet node implemented in Rust and version 0.1.0 Common Structures \u00b6 Common structures used along different Witnet network messages. Address Format \u00b6 Witnet peer addresses are defined as follows: Field Type Description ipv4 u32 IPv4 address of the peer port u16 port number in which the peer is listening Alternatively, IP addresses may be IPv6: Field Type Description ipv6 [u32; 4] IPv6 address of the peer port u16 port number in which the peer is listening Messages \u00b6 The current network protocol includes the description and definition of the following messages: VERSION VERACK GET_PEERS PEERS PING PONG All of these messages include a message header identifying which message type is being sent. Message Header \u00b6 Inspired in other blockchains, the message header format is composed of the following fields: Field Type Description magic u16 magic value indicating message origin network command string message being sent from a predefined list of available commands payload ? message data Handshake (VERSION, VERACK) \u00b6 The protocol to connect from a local peer (initiator) to a known remote peer, also known as \"handshake\", starts with a TCP connection to a given IP address and port. The handshake initiator, the local peer, sends a version message to the remote peer. The remote peer will analyze the information in order to evaluate if the submitting peer is compatible regarding their supported versions and capabilities. If so, the remote peer will acknowledge the version message and establish a connection by sending a verack message. The version message contains the following information: Field Type Description version u32 the Witnet p2p protocol version that the client is using timestamp u64 the current time in UTC format capabilities u64 list of flags of supported services, by default NODE_NETWORK is used sender_address addr the IP address and port of the handshake initiator peer receiver_address addr the IP address and port of the remote peer user_agent string a version showing which software is running the local peer last_epoch u32 last epoch in the local peer blockchain genesis [u32; 8] hash of the genesis block nonce u64 Node random nonce, randomly generated every time a version packet is sent (used to detect connections to self) The verack message is sent as reply to the version and it only consists of a message header with the command VERACK . Subsequently, the handshake initiator will expect a version message from the remote peer. The local peer will also acknowledge by replying with a verack message. Connection cannot be considered as establish until both verack messages have been received by both peers. After sending a version message the peers will define a timeout to wait for a response. If no response is received during this timeout (usually set to 10 seconds), the peer will be discarded from the known peers list. Peer discovery (GET_PEERS, PEERS) \u00b6 In Witnet, a node must always establish different paths into the network by connecting to different peers, ideally randomly selected. As connections may disappear, network peers should assist others when they bootstrap. After establishing a connection with remote peers (throughout a handshake mechanism), a node may request to their remote peer to receive a list of their known \"recent\" peers. This request is initiated by sending a get_peers message to a remote peer. The receiving node will reply with a peers message with a list of peer addresses that have been seen recently active in the network. The typical assumption is that a node is likely to be active if it has sent any message during the last 90 minutes. The transmitting node will then update those IP addresses and ports into its database of available nodes. The get_peers message only consists of the message header with the command GET_PEERS . The peers message consists of the message header with the command PEERS and as payload it contains a list of known peers as: Field Type Description peers addr[] list of addresses of active known peers Heartbeat (PING, PONG) \u00b6 As in Bitcoin, the heartbeat protocol is defined with ping and pong messages and it is defined as follows: If during the last 30 minutes a peer has no transmitted any message, it will send a heartbeat as ping message. If in the last 90 minutes no message has been received by a remote peer, the local node will assume that the connection has been closed. The ping message confirms that the connection is still valid. The pong message is sent in response to a ping message. Both contain only one field: Field Type Description nonce u64 a random number Error messages \u00b6 The error messages are structured as follow: Field Type Description code u32 predefined error code message string user friendly message References \u00b6 Bitcoin: Developer Reference - Bitcoin Wiki GitHub - bitcoin/bitcoin: Bitcoin Core integration/staging tree GitHub - paritytech/parity-bitcoin: The Parity Bitcoin client Ethereum: Wiki \u00b7 GitHub GitHub - ethereum/go-ethereum: Official Go implementation of the Ethereum protocol GitHub - paritytech/parity-ethereum: The fast, light, and robust EVM and WASM client. RChain: Documentation GitHub - rchain/rchain Mimblewimble Grin: Grin, the Tech | Simple, privacy-focused, scalable MimbleWimble chain implementation. Wiki \u00b7 GitHub GitHub - mimblewimble/grin: Minimal implementation of the MimbleWimble protocol. Exonum: Exonum Documentation GitHub - exonum/exonum: An extensible open-source framework for creating private/permissioned blockchain applications","title":"Network messages"},{"location":"protocol/network/#witnet-network-protocol","text":"Witnet network protocol is inspired in other blockchain network protocols such as Bitcoin, Ethereum and Rchain. Additionally, other blockchains such as Grin and Exonum have been taken into consideration as their reference implementations are coded in Rust.","title":"Witnet Network Protocol"},{"location":"protocol/network/#initial-considerations","text":"In order to start the network discovery process, at least one existing node on the network is required. However, in order to avoid unnecessary risks or potential attack vectors, it is always recommended to know several existing nodes extracted from different sources.","title":"Initial considerations"},{"location":"protocol/network/#peer-bootstrapping-methods","text":"The strategy for selecting the first node to connect should be random, thus it should not depend on geographical position or any other network parameter. The client discovers the IP addresses and ports of other nodes in a decentralized way, i.e. there should not be a central point of trust or failure to bootstrap the network. For example, some of the considered approaches for bootstrapping a new peer into the network could one or more of the following methods: Hard coded addresses Addresses provided as command line arguments Addresses provided from user provided text file on startup Store addresses in database and read them on startup Exchange addresses with other nodes DNS requests to receive IP addresses IRC channel where peers are advertised","title":"Peer bootstrapping methods"},{"location":"protocol/network/#constants-and-defaults","text":"Witnet constants and default values used in the network protocol.","title":"Constants and Defaults"},{"location":"protocol/network/#default-values","text":"Network Default Port mainnet 11337 testnet 21337","title":"Default Values"},{"location":"protocol/network/#witnet-versions","text":"Below the existing versions of the Witnet P2P network protocol are listed: Version Initial Release Major Changes 010 to be determined","title":"Witnet versions"},{"location":"protocol/network/#magic-numbers","text":"These constant values indicate the originating network in the message headers: Network Magic number mainnet 0x00 testnet 0xF0","title":"Magic numbers"},{"location":"protocol/network/#node-capabilities","text":"Currently, only one node capabilities is being offered by Witnet: Flag Description 0x0000000000000001 NODE_NETWORK, Witnet full node which is the default operation mode","title":"Node capabilities"},{"location":"protocol/network/#user-agents","text":"Currently, only one user agent is being developed: User Agent Description /Witnet-rust:0.1.0 Witnet node implemented in Rust and version 0.1.0","title":"User agents"},{"location":"protocol/network/#common-structures","text":"Common structures used along different Witnet network messages.","title":"Common Structures"},{"location":"protocol/network/#address-format","text":"Witnet peer addresses are defined as follows: Field Type Description ipv4 u32 IPv4 address of the peer port u16 port number in which the peer is listening Alternatively, IP addresses may be IPv6: Field Type Description ipv6 [u32; 4] IPv6 address of the peer port u16 port number in which the peer is listening","title":"Address Format"},{"location":"protocol/network/#messages","text":"The current network protocol includes the description and definition of the following messages: VERSION VERACK GET_PEERS PEERS PING PONG All of these messages include a message header identifying which message type is being sent.","title":"Messages"},{"location":"protocol/network/#message-header","text":"Inspired in other blockchains, the message header format is composed of the following fields: Field Type Description magic u16 magic value indicating message origin network command string message being sent from a predefined list of available commands payload ? message data","title":"Message Header"},{"location":"protocol/network/#handshake-version-verack","text":"The protocol to connect from a local peer (initiator) to a known remote peer, also known as \"handshake\", starts with a TCP connection to a given IP address and port. The handshake initiator, the local peer, sends a version message to the remote peer. The remote peer will analyze the information in order to evaluate if the submitting peer is compatible regarding their supported versions and capabilities. If so, the remote peer will acknowledge the version message and establish a connection by sending a verack message. The version message contains the following information: Field Type Description version u32 the Witnet p2p protocol version that the client is using timestamp u64 the current time in UTC format capabilities u64 list of flags of supported services, by default NODE_NETWORK is used sender_address addr the IP address and port of the handshake initiator peer receiver_address addr the IP address and port of the remote peer user_agent string a version showing which software is running the local peer last_epoch u32 last epoch in the local peer blockchain genesis [u32; 8] hash of the genesis block nonce u64 Node random nonce, randomly generated every time a version packet is sent (used to detect connections to self) The verack message is sent as reply to the version and it only consists of a message header with the command VERACK . Subsequently, the handshake initiator will expect a version message from the remote peer. The local peer will also acknowledge by replying with a verack message. Connection cannot be considered as establish until both verack messages have been received by both peers. After sending a version message the peers will define a timeout to wait for a response. If no response is received during this timeout (usually set to 10 seconds), the peer will be discarded from the known peers list.","title":"Handshake (VERSION, VERACK)"},{"location":"protocol/network/#peer-discovery-get_peers-peers","text":"In Witnet, a node must always establish different paths into the network by connecting to different peers, ideally randomly selected. As connections may disappear, network peers should assist others when they bootstrap. After establishing a connection with remote peers (throughout a handshake mechanism), a node may request to their remote peer to receive a list of their known \"recent\" peers. This request is initiated by sending a get_peers message to a remote peer. The receiving node will reply with a peers message with a list of peer addresses that have been seen recently active in the network. The typical assumption is that a node is likely to be active if it has sent any message during the last 90 minutes. The transmitting node will then update those IP addresses and ports into its database of available nodes. The get_peers message only consists of the message header with the command GET_PEERS . The peers message consists of the message header with the command PEERS and as payload it contains a list of known peers as: Field Type Description peers addr[] list of addresses of active known peers","title":"Peer discovery (GET_PEERS, PEERS)"},{"location":"protocol/network/#heartbeat-ping-pong","text":"As in Bitcoin, the heartbeat protocol is defined with ping and pong messages and it is defined as follows: If during the last 30 minutes a peer has no transmitted any message, it will send a heartbeat as ping message. If in the last 90 minutes no message has been received by a remote peer, the local node will assume that the connection has been closed. The ping message confirms that the connection is still valid. The pong message is sent in response to a ping message. Both contain only one field: Field Type Description nonce u64 a random number","title":"Heartbeat (PING, PONG)"},{"location":"protocol/network/#error-messages","text":"The error messages are structured as follow: Field Type Description code u32 predefined error code message string user friendly message","title":"Error messages"},{"location":"protocol/network/#references","text":"Bitcoin: Developer Reference - Bitcoin Wiki GitHub - bitcoin/bitcoin: Bitcoin Core integration/staging tree GitHub - paritytech/parity-bitcoin: The Parity Bitcoin client Ethereum: Wiki \u00b7 GitHub GitHub - ethereum/go-ethereum: Official Go implementation of the Ethereum protocol GitHub - paritytech/parity-ethereum: The fast, light, and robust EVM and WASM client. RChain: Documentation GitHub - rchain/rchain Mimblewimble Grin: Grin, the Tech | Simple, privacy-focused, scalable MimbleWimble chain implementation. Wiki \u00b7 GitHub GitHub - mimblewimble/grin: Minimal implementation of the MimbleWimble protocol. Exonum: Exonum Documentation GitHub - exonum/exonum: An extensible open-source framework for creating private/permissioned blockchain applications","title":"References"},{"location":"protocol/data-requests/overview/","text":"Data requests \u00b6 Data requests are the cornerstone of the Witnet protocol. They allow clients to have witness nodes retrieve , aggregate and deliver data on their behalf on demand. Request life cycle \u00b6 Once a data request has been published by a client, it will go through 4 distinct phases: retrieval , aggregation , consensus and delivery . These phases are linear and constitute a single, unidirectional data flow. \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 Client \u2551 \u2551 Witnesses \u2551 \u2551 Miner \u2551 \u2551 Bridge \u2551 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2551 Publish \u2551 => \u2551 Retrieve => Aggregate \u2551 => \u2551 Consensus \u2551 => \u2551 Deliver \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2551 Retrieve => Aggregate \u2551 \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u2551 ... (as many as requested) \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d In each phase, its input data is the output data of the previous phase. For the sake of deterministic execution, data flowing through the different phases is strongly typed. The type of a value or data structure defines the operations that can be done on the data. In each phase, its input data type is the output data type of the previous phase. Particularly, the aggregation and consensus phases gather multiple values or structures emitted by their precedent phases, so they always receive an Array . For more information on data types, you can read the RADON documentation , which provides a detailed description of all the types and the operators they provide. The RAD Engine \u00b6 The RAD Engine is the component in charge of processing data requests coming from Witnet clients. That is, coordinating retrieval, aggregation, consensus and delivery of data strictly as specified in the requests. All data requests contain explicit instructions on what the RAD Engine must do during every phase. These instructions, specified using RAD Object Notation (RADON) , are interpreted by the RAD Engine. Just in case you were asking, RAD stands for Retrieve , Aggregate and Deliver . RAD Object Notation (RADON) \u00b6 The RAD Object Notation (RADON) is a low-level, declarative, functional, strongly-typed, Non-Turing complete programming language. A RADON script is formed by a list of ordered calls (tuples of operators and arguments) that are sequentially interpreted and applied by the RAD Engine on the output of the previous call. Creating data requests \u00b6 The RAD Engine is only capable of interpreting well-formed RADON scripts . Even though human beings can safely write RADON without their heads exploding \ud83e\udd2f, they are just expected to do not. The higher-level RADlang programming language should be used instead for writing data requests in a much more expressive and user-friendly way. The Sheikah desktop app is intended to be used as an IDE for Witnet data requests, so it will act as a compiler for transforming RADlang into RADON. While RADlang and Sheikah are maintained by Witnet Foundation, other third-party developers can create their own high-level programming languages to abstract away from the complexity of RADON.","title":"Overview"},{"location":"protocol/data-requests/overview/#data-requests","text":"Data requests are the cornerstone of the Witnet protocol. They allow clients to have witness nodes retrieve , aggregate and deliver data on their behalf on demand.","title":"Data requests"},{"location":"protocol/data-requests/overview/#request-life-cycle","text":"Once a data request has been published by a client, it will go through 4 distinct phases: retrieval , aggregation , consensus and delivery . These phases are linear and constitute a single, unidirectional data flow. \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 Client \u2551 \u2551 Witnesses \u2551 \u2551 Miner \u2551 \u2551 Bridge \u2551 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2551 Publish \u2551 => \u2551 Retrieve => Aggregate \u2551 => \u2551 Consensus \u2551 => \u2551 Deliver \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2551 Retrieve => Aggregate \u2551 \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u2551 ... (as many as requested) \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d In each phase, its input data is the output data of the previous phase. For the sake of deterministic execution, data flowing through the different phases is strongly typed. The type of a value or data structure defines the operations that can be done on the data. In each phase, its input data type is the output data type of the previous phase. Particularly, the aggregation and consensus phases gather multiple values or structures emitted by their precedent phases, so they always receive an Array . For more information on data types, you can read the RADON documentation , which provides a detailed description of all the types and the operators they provide.","title":"Request life cycle"},{"location":"protocol/data-requests/overview/#the-rad-engine","text":"The RAD Engine is the component in charge of processing data requests coming from Witnet clients. That is, coordinating retrieval, aggregation, consensus and delivery of data strictly as specified in the requests. All data requests contain explicit instructions on what the RAD Engine must do during every phase. These instructions, specified using RAD Object Notation (RADON) , are interpreted by the RAD Engine. Just in case you were asking, RAD stands for Retrieve , Aggregate and Deliver .","title":"The RAD Engine"},{"location":"protocol/data-requests/overview/#rad-object-notation-radon","text":"The RAD Object Notation (RADON) is a low-level, declarative, functional, strongly-typed, Non-Turing complete programming language. A RADON script is formed by a list of ordered calls (tuples of operators and arguments) that are sequentially interpreted and applied by the RAD Engine on the output of the previous call.","title":"RAD Object Notation (RADON)"},{"location":"protocol/data-requests/overview/#creating-data-requests","text":"The RAD Engine is only capable of interpreting well-formed RADON scripts . Even though human beings can safely write RADON without their heads exploding \ud83e\udd2f, they are just expected to do not. The higher-level RADlang programming language should be used instead for writing data requests in a much more expressive and user-friendly way. The Sheikah desktop app is intended to be used as an IDE for Witnet data requests, so it will act as a compiler for transforming RADlang into RADON. While RADlang and Sheikah are maintained by Witnet Foundation, other third-party developers can create their own high-level programming languages to abstract away from the complexity of RADON.","title":"Creating data requests"},{"location":"protocol/data-requests/radon/constants/","text":"Constants \u00b6 Types \u00b6 Byte Decimal Constant 0x00 0 TYPE_BOOLEAN 0x01 1 TYPE_INT 0x02 2 TYPE_FLOAT 0x03 3 TYPE_STRING 0x04 4 TYPE_ARRAY 0x05 5 TYPE_MAP 0x06 6 TYPE_MIXED 0x07 7 TYPE_NULL 0x08 8 TYPE_RESULT Operators \u00b6 Boolean operators \u00b6 Byte Decimal Constant 0x00 0 BOOLEAN_MATCH 0x01 1 BOOLEAN_NEG 0x02 2 BOOLEAN_TOSTRING Int operators \u00b6 Byte Decimal Constant 0x00 0 INT_ABS 0x01 1 INT_MATCH 0x02 2 INT_MODULO 0x03 3 INT_MULT 0x04 4 INT_NEG 0x05 5 INT_POW 0x06 6 INT_RECIP 0x07 7 INT_SUM 0x08 8 INT_TOFLOAT 0x09 9 INT_TOSTRING Float operators \u00b6 Byte Decimal Constant 0x00 0 FLOAT_ABS 0x01 1 FLOAT_CEIL 0x02 2 FLOAT_FLOOR 0x03 3 FLOAT_MODULO 0x04 4 FLOAT_MULT 0x05 5 FLOAT_NEG 0x06 6 FLOAT_POW 0x07 7 FLOAT_RECIP 0x08 8 FLOAT_ROUND 0x09 9 FLOAT_SUM 0x0a 10 FLOAT_TOSTRING 0x0b 11 FLOAT_TRUNC String operators \u00b6 Byte Decimal Constant 0x00 0 STRING_HASH 0x01 1 STRING_LENGTH 0x02 2 STRING_MATCH 0x03 3 STRING_PARSEJSON 0x04 4 STRING_PARSEXML 0x05 5 STRING_TOBOOLEAN 0x06 6 STRING_TOFLOAT 0x07 7 STRING_TOINT 0x08 8 STRING_TOLOWERCASE 0x09 9 STRING_TOUPPERCASE Array operators \u00b6 Byte Decimal Constant 0x00 0 ARRAY_COUNT 0x01 1 ARRAY_EVERY 0x02 2 ARRAY_FILTER 0x03 3 ARRAY_FLATTEN 0x04 4 ARRAY_GET 0x05 5 ARRAY_MAP 0x06 6 ARRAY_REDUCE 0x07 7 ARRAY_SOME 0x08 8 ARRAY_SORT 0x09 9 ARRAY_TAKE Map operators \u00b6 Byte Decimal Constant 0x00 0 MAP_ENTRIES 0x00 0 MAP_GET 0x00 0 MAP_KEYS 0x00 0 MAP_VALUES Mixed operators \u00b6 Byte Decimal Constant 0x00 0 MIXED_TOARRAY 0x01 1 MIXED_TOBOOLEAN 0x02 2 MIXED_TOFLOAT 0x03 3 MIXED_TOINT 0x04 4 MIXED_TOMAP Result operators \u00b6 Byte Decimal Constant 0x00 0 RESULT_GET 0x01 1 RESULT_GETOR 0x02 2 RESULT_ISOK Hash functions \u00b6 Byte Decimal Constant 0x00 0 BLAKE_256 0x01 1 BLAKE_512 0x02 2 BLAKE2S_256 0x03 3 BLAKE2B_512 0x04 4 MD5_128 0x05 5 RIPEMD_128 0x06 6 RIPEMD_160 0x07 7 RIPEMD_320 0x08 8 SHA1_160 0x09 9 SHA2_224 0x0a 10 SHA2_256 0x0b 11 SHA2_384 0x0c 12 SHA2_512 0x0d 13 SHA3_224 0x0e 14 SHA3_256 0x0f 15 SHA3_384 0x10 16 SHA3_512 0x11 17 WHIRLPOOL_512 Filtering functions \u00b6 Byte Decimal Constant 0x00 0 FILTER_GT 0x01 1 FILTER_LT 0x02 2 FILTER_EQ 0x03 3 FILTER_DEV_ABS 0x04 4 FILTER_DEV_REL 0x05 5 FILTER_DEV_STD 0x06 6 FILTER_TOP 0x07 7 FILTER_BOTTOM 0x80 128 FILTER_NOT_GT 0x81 129 FILTER_NOT_LT 0x82 130 FILTER_NOT_EQ 0x83 131 FILTER_NOT_DEV_ABS 0x84 132 FILTER_NOT_DEV_REL 0x85 133 FILTER_NOT_DEV_STD 0x86 134 FILTER_NOT_TOP 0x87 135 FILTER_NOT_BOTTOM Tip Negative filtering functions constants always equate to the value of their positive counterpart plus 128 . Reducing functions \u00b6 Byte Decimal Constant 0x00 0 REDUCER_MIN 0x01 1 REDUCER_MAX 0x02 2 REDUCER_MODE 0x03 3 REDUCER_AVG_MEAN 0x04 4 REDUCER_AVG_MEAN_W 0x05 5 REDUCER_AVG_MEDIAN 0x06 6 REDUCER_AVG_MEDIAN_W 0x07 7 REDUCER_DEV_STD 0x08 8 REDUCER_DEV_AVG 0x09 9 REDUCER_DEV_MED 0x0a 10 REDUCER_DEV_MAX","title":"Constants"},{"location":"protocol/data-requests/radon/constants/#constants","text":"","title":"Constants"},{"location":"protocol/data-requests/radon/constants/#types","text":"Byte Decimal Constant 0x00 0 TYPE_BOOLEAN 0x01 1 TYPE_INT 0x02 2 TYPE_FLOAT 0x03 3 TYPE_STRING 0x04 4 TYPE_ARRAY 0x05 5 TYPE_MAP 0x06 6 TYPE_MIXED 0x07 7 TYPE_NULL 0x08 8 TYPE_RESULT","title":"Types"},{"location":"protocol/data-requests/radon/constants/#operators","text":"","title":"Operators"},{"location":"protocol/data-requests/radon/constants/#boolean-operators","text":"Byte Decimal Constant 0x00 0 BOOLEAN_MATCH 0x01 1 BOOLEAN_NEG 0x02 2 BOOLEAN_TOSTRING","title":"Boolean operators"},{"location":"protocol/data-requests/radon/constants/#int-operators","text":"Byte Decimal Constant 0x00 0 INT_ABS 0x01 1 INT_MATCH 0x02 2 INT_MODULO 0x03 3 INT_MULT 0x04 4 INT_NEG 0x05 5 INT_POW 0x06 6 INT_RECIP 0x07 7 INT_SUM 0x08 8 INT_TOFLOAT 0x09 9 INT_TOSTRING","title":"Int operators"},{"location":"protocol/data-requests/radon/constants/#float-operators","text":"Byte Decimal Constant 0x00 0 FLOAT_ABS 0x01 1 FLOAT_CEIL 0x02 2 FLOAT_FLOOR 0x03 3 FLOAT_MODULO 0x04 4 FLOAT_MULT 0x05 5 FLOAT_NEG 0x06 6 FLOAT_POW 0x07 7 FLOAT_RECIP 0x08 8 FLOAT_ROUND 0x09 9 FLOAT_SUM 0x0a 10 FLOAT_TOSTRING 0x0b 11 FLOAT_TRUNC","title":"Float operators"},{"location":"protocol/data-requests/radon/constants/#string-operators","text":"Byte Decimal Constant 0x00 0 STRING_HASH 0x01 1 STRING_LENGTH 0x02 2 STRING_MATCH 0x03 3 STRING_PARSEJSON 0x04 4 STRING_PARSEXML 0x05 5 STRING_TOBOOLEAN 0x06 6 STRING_TOFLOAT 0x07 7 STRING_TOINT 0x08 8 STRING_TOLOWERCASE 0x09 9 STRING_TOUPPERCASE","title":"String operators"},{"location":"protocol/data-requests/radon/constants/#array-operators","text":"Byte Decimal Constant 0x00 0 ARRAY_COUNT 0x01 1 ARRAY_EVERY 0x02 2 ARRAY_FILTER 0x03 3 ARRAY_FLATTEN 0x04 4 ARRAY_GET 0x05 5 ARRAY_MAP 0x06 6 ARRAY_REDUCE 0x07 7 ARRAY_SOME 0x08 8 ARRAY_SORT 0x09 9 ARRAY_TAKE","title":"Array operators"},{"location":"protocol/data-requests/radon/constants/#map-operators","text":"Byte Decimal Constant 0x00 0 MAP_ENTRIES 0x00 0 MAP_GET 0x00 0 MAP_KEYS 0x00 0 MAP_VALUES","title":"Map operators"},{"location":"protocol/data-requests/radon/constants/#mixed-operators","text":"Byte Decimal Constant 0x00 0 MIXED_TOARRAY 0x01 1 MIXED_TOBOOLEAN 0x02 2 MIXED_TOFLOAT 0x03 3 MIXED_TOINT 0x04 4 MIXED_TOMAP","title":"Mixed operators"},{"location":"protocol/data-requests/radon/constants/#result-operators","text":"Byte Decimal Constant 0x00 0 RESULT_GET 0x01 1 RESULT_GETOR 0x02 2 RESULT_ISOK","title":"Result operators"},{"location":"protocol/data-requests/radon/constants/#hash-functions","text":"Byte Decimal Constant 0x00 0 BLAKE_256 0x01 1 BLAKE_512 0x02 2 BLAKE2S_256 0x03 3 BLAKE2B_512 0x04 4 MD5_128 0x05 5 RIPEMD_128 0x06 6 RIPEMD_160 0x07 7 RIPEMD_320 0x08 8 SHA1_160 0x09 9 SHA2_224 0x0a 10 SHA2_256 0x0b 11 SHA2_384 0x0c 12 SHA2_512 0x0d 13 SHA3_224 0x0e 14 SHA3_256 0x0f 15 SHA3_384 0x10 16 SHA3_512 0x11 17 WHIRLPOOL_512","title":"Hash functions"},{"location":"protocol/data-requests/radon/constants/#filtering-functions","text":"Byte Decimal Constant 0x00 0 FILTER_GT 0x01 1 FILTER_LT 0x02 2 FILTER_EQ 0x03 3 FILTER_DEV_ABS 0x04 4 FILTER_DEV_REL 0x05 5 FILTER_DEV_STD 0x06 6 FILTER_TOP 0x07 7 FILTER_BOTTOM 0x80 128 FILTER_NOT_GT 0x81 129 FILTER_NOT_LT 0x82 130 FILTER_NOT_EQ 0x83 131 FILTER_NOT_DEV_ABS 0x84 132 FILTER_NOT_DEV_REL 0x85 133 FILTER_NOT_DEV_STD 0x86 134 FILTER_NOT_TOP 0x87 135 FILTER_NOT_BOTTOM Tip Negative filtering functions constants always equate to the value of their positive counterpart plus 128 .","title":"Filtering functions"},{"location":"protocol/data-requests/radon/constants/#reducing-functions","text":"Byte Decimal Constant 0x00 0 REDUCER_MIN 0x01 1 REDUCER_MAX 0x02 2 REDUCER_MODE 0x03 3 REDUCER_AVG_MEAN 0x04 4 REDUCER_AVG_MEAN_W 0x05 5 REDUCER_AVG_MEDIAN 0x06 6 REDUCER_AVG_MEDIAN_W 0x07 7 REDUCER_DEV_STD 0x08 8 REDUCER_DEV_AVG 0x09 9 REDUCER_DEV_MED 0x0a 10 REDUCER_DEV_MAX","title":"Reducing functions"},{"location":"protocol/data-requests/radon/encoding/","text":"RADON encoding \u00b6 RADON scripts are encoded using MessagePack , a very efficient, compact and widely supported data structure encoding. Before encoding, a RADON script looks like this: [ STRING_PARSEJSON , MIXED_TOMAP , [ MAP_GET , \"weather\" ], MIXED_TOMAP , [ MAP_GET , \"temp\" ], MIXED_TOFLOAT ] After encoding, we get an impressively compact (22 bytes long) output: // Base64 lgMEkgCnd2VhdGhlcgSSAKR0ZW1wAg Constants All across this documentation, unquoted uppercase names like STRING_PARSEJSON identify different operators and constants that equate to a single byte when encoded. A list of constants can be found in the Constants section .","title":"Encoding"},{"location":"protocol/data-requests/radon/encoding/#radon-encoding","text":"RADON scripts are encoded using MessagePack , a very efficient, compact and widely supported data structure encoding. Before encoding, a RADON script looks like this: [ STRING_PARSEJSON , MIXED_TOMAP , [ MAP_GET , \"weather\" ], MIXED_TOMAP , [ MAP_GET , \"temp\" ], MIXED_TOFLOAT ] After encoding, we get an impressively compact (22 bytes long) output: // Base64 lgMEkgCnd2VhdGhlcgSSAKR0ZW1wAg Constants All across this documentation, unquoted uppercase names like STRING_PARSEJSON identify different operators and constants that equate to a single byte when encoded. A list of constants can be found in the Constants section .","title":"RADON encoding"},{"location":"protocol/data-requests/radon/examples/","text":"Examples \u00b6 Retrieval phase \u00b6 [ // String STRING_PARSEJSON , // Mixed MIXED_TOMAP , // Map<String, Mixed> [ MAP_GET , \"main\" ], // Mixed MIXED_TOMAP , // Map<String, Mixed> [ MAP_GET , \"temp\" ], // Mixed MIXED_TOFLOAT // Float ] // Result<Float> This example retrieval script does the following on the result of this OpenWeatherMap API call : Parse the input String as a JSON document (retrieval always starts with String ), Treat the structure as a Map<String, Mixed> , Take the value of the \"main\" key, Treat the structure as a Map<String, Mixed> . Take the value of the \"temp\" key, Emit the value as a Float . Aggregation phase \u00b6 [ // Array<Result<Float>> ARRAY_FLATMAP , // Array<Float> [ ARRAY_FILTER , FILTER_GT , - 30 ], // Array<Float> [ ARRAY_FILTER , FILTER_LT , 50 ], // Array<Float> [ ARRAY_FILTER , FILTER_DEV_ABS , 2 ], // Array<Float> [ ARRAY_REDUCE , REDUCER_AVG_MEAN ] // Float ] // Result<Float> This example aggregation script does the following: Drop every negative Result ( Err items) from the input Array , Drop values less or equal than -30 , Drop values greater or equal than 50 , Drop values deviating from the average more than 2 , Calculate and emit the arithmetic mean of the remaining values in the Array . Consensus phase \u00b6 [ // Array<Result<Float>> ARRAY_FLATMAP , [ ARRAY_REDUCE , REDUCE_AVG_MEAN ] // Float ] // Result<Float> This example consensus script does the following: Drop every negative Result ( Err items) from the input Array , Calculate and emit the arithmetic mean of the remaining values in the Array .","title":"Examples"},{"location":"protocol/data-requests/radon/examples/#examples","text":"","title":"Examples"},{"location":"protocol/data-requests/radon/examples/#retrieval-phase","text":"[ // String STRING_PARSEJSON , // Mixed MIXED_TOMAP , // Map<String, Mixed> [ MAP_GET , \"main\" ], // Mixed MIXED_TOMAP , // Map<String, Mixed> [ MAP_GET , \"temp\" ], // Mixed MIXED_TOFLOAT // Float ] // Result<Float> This example retrieval script does the following on the result of this OpenWeatherMap API call : Parse the input String as a JSON document (retrieval always starts with String ), Treat the structure as a Map<String, Mixed> , Take the value of the \"main\" key, Treat the structure as a Map<String, Mixed> . Take the value of the \"temp\" key, Emit the value as a Float .","title":"Retrieval phase"},{"location":"protocol/data-requests/radon/examples/#aggregation-phase","text":"[ // Array<Result<Float>> ARRAY_FLATMAP , // Array<Float> [ ARRAY_FILTER , FILTER_GT , - 30 ], // Array<Float> [ ARRAY_FILTER , FILTER_LT , 50 ], // Array<Float> [ ARRAY_FILTER , FILTER_DEV_ABS , 2 ], // Array<Float> [ ARRAY_REDUCE , REDUCER_AVG_MEAN ] // Float ] // Result<Float> This example aggregation script does the following: Drop every negative Result ( Err items) from the input Array , Drop values less or equal than -30 , Drop values greater or equal than 50 , Drop values deviating from the average more than 2 , Calculate and emit the arithmetic mean of the remaining values in the Array .","title":"Aggregation phase"},{"location":"protocol/data-requests/radon/examples/#consensus-phase","text":"[ // Array<Result<Float>> ARRAY_FLATMAP , [ ARRAY_REDUCE , REDUCE_AVG_MEAN ] // Float ] // Result<Float> This example consensus script does the following: Drop every negative Result ( Err items) from the input Array , Calculate and emit the arithmetic mean of the remaining values in the Array .","title":"Consensus phase"},{"location":"protocol/data-requests/radon/exceptions/","text":"Exception handling \u00b6 When a call in a RADON script causes a runtime exception, the script execution flow is immediately stopped. But do not panic: this does not seem the entire data request will fail. RADON has a solid strategy for recovering from those situations. Exceptions generated in a certain phase in the data request life cycle do progress to the next phase wrapped in a Result<V> with value Err . This provides a type safe API for handling success and errors in a uniform way, and gives the developer the choice to recover from exceptions as appropriate for the use case (dropping errors, mapping them into default values, etc.)","title":"Exception handling"},{"location":"protocol/data-requests/radon/exceptions/#exception-handling","text":"When a call in a RADON script causes a runtime exception, the script execution flow is immediately stopped. But do not panic: this does not seem the entire data request will fail. RADON has a solid strategy for recovering from those situations. Exceptions generated in a certain phase in the data request life cycle do progress to the next phase wrapped in a Result<V> with value Err . This provides a type safe API for handling success and errors in a uniform way, and gives the developer the choice to recover from exceptions as appropriate for the use case (dropping errors, mapping them into default values, etc.)","title":"Exception handling"},{"location":"protocol/data-requests/radon/functions/","text":"Predefined functions \u00b6 Filtering functions \u00b6 gt : must be greater than the provided value. lt : must be less than the provided value. eq : must equal the provided value. dev-$type : must not deviate from the average. This has three subtypes: dev-abs : must not deviate from the average more than the provided absolute value. dev-rel : must not deviate from the average more than the provided relative value (e.g.: 0.5 is 50%). dev-std : must not deviate from the average more than value times the standard deviation of the values in the Array , where value is typically a Float between 1 (picky) and 3 (relaxed). top : must be amongst the value highest values in the Array . bottom : must be amongst the value lowest values in the Array . not-$function : applies the opposite of any of the previous functions (e.g.: not-lt equates to \"greater or equal than\" ). The implicit signature for all of the filtering functions is: ( value : T ) : Boolean Some functions that compare individual values to the values in the Array are pointless if used along the some operator as they will make it return False every time. These include: top bottom Reducing functions \u00b6 min : takes the minimum value. max : takes the maximum value. mode : takes the mode . That is, the value that appears the more often. avg-$type : calculates the average of the values in the Array . This has four subtypes: avg-mean : arithmetic mean . avg-mean-w : weighted mean . avg-median : median . avg-median-w : weighted median . dev-$type : measures the dispersion of the values in the Array . This has four subtypes: dev-std : standard deviation . dev-avg : average absolute deviation . dev-med : median absolute deviation . dev-max : maximum absolute deviation . Hash functions \u00b6 BLAKE family: blake-256 blake-512 blake2s-256 blake2b-512 MD5: md5-128 RIPEMD family: ripemd-128 ripemd-160 ripemd-320 SHA1: sha1-160 SHA2 family: sha2-224 sha2-256 sha2-384 sha2-512 SHA3 family: sha3-224 sha3-256 sha3-384 sha3-512 Whirlpool: whirlpool-512 Safety of deprecated hash functions The md5-128 and sha1-160 hash functions are provided solely for the sake of backward compatibility with legacy software and systems. Depending on the use case, they may not live up to minimum acceptable security standards. Please refrain from using those for new software and systems unless strictly necessary.","title":"Predefined functions"},{"location":"protocol/data-requests/radon/functions/#predefined-functions","text":"","title":"Predefined functions"},{"location":"protocol/data-requests/radon/functions/#filtering-functions","text":"gt : must be greater than the provided value. lt : must be less than the provided value. eq : must equal the provided value. dev-$type : must not deviate from the average. This has three subtypes: dev-abs : must not deviate from the average more than the provided absolute value. dev-rel : must not deviate from the average more than the provided relative value (e.g.: 0.5 is 50%). dev-std : must not deviate from the average more than value times the standard deviation of the values in the Array , where value is typically a Float between 1 (picky) and 3 (relaxed). top : must be amongst the value highest values in the Array . bottom : must be amongst the value lowest values in the Array . not-$function : applies the opposite of any of the previous functions (e.g.: not-lt equates to \"greater or equal than\" ). The implicit signature for all of the filtering functions is: ( value : T ) : Boolean Some functions that compare individual values to the values in the Array are pointless if used along the some operator as they will make it return False every time. These include: top bottom","title":"Filtering functions"},{"location":"protocol/data-requests/radon/functions/#reducing-functions","text":"min : takes the minimum value. max : takes the maximum value. mode : takes the mode . That is, the value that appears the more often. avg-$type : calculates the average of the values in the Array . This has four subtypes: avg-mean : arithmetic mean . avg-mean-w : weighted mean . avg-median : median . avg-median-w : weighted median . dev-$type : measures the dispersion of the values in the Array . This has four subtypes: dev-std : standard deviation . dev-avg : average absolute deviation . dev-med : median absolute deviation . dev-max : maximum absolute deviation .","title":"Reducing functions"},{"location":"protocol/data-requests/radon/functions/#hash-functions","text":"BLAKE family: blake-256 blake-512 blake2s-256 blake2b-512 MD5: md5-128 RIPEMD family: ripemd-128 ripemd-160 ripemd-320 SHA1: sha1-160 SHA2 family: sha2-224 sha2-256 sha2-384 sha2-512 SHA3 family: sha3-224 sha3-256 sha3-384 sha3-512 Whirlpool: whirlpool-512 Safety of deprecated hash functions The md5-128 and sha1-160 hash functions are provided solely for the sake of backward compatibility with legacy software and systems. Depending on the use case, they may not live up to minimum acceptable security standards. Please refrain from using those for new software and systems unless strictly necessary.","title":"Hash functions"},{"location":"protocol/data-requests/radon/subscripts/","text":"Subscripts \u00b6 Some operators like allow specifying particular sequences of calls (scripts) that will be executed inside the scope of the operator itself. We name those as subscripts . That is the case for the Array<T>::map<0>(subscript: (item: T) => O) operator, which applies a subscript in parallel on every T item found in the input Array<T> and then collects the results of the (item: T) => 0 subscripts into a single Array<O> that commits to have the same number of items as the input Array<T> . Therefore, the first call in a subscript must be compatible with the type of the input.","title":"Subscripts"},{"location":"protocol/data-requests/radon/subscripts/#subscripts","text":"Some operators like allow specifying particular sequences of calls (scripts) that will be executed inside the scope of the operator itself. We name those as subscripts . That is the case for the Array<T>::map<0>(subscript: (item: T) => O) operator, which applies a subscript in parallel on every T item found in the input Array<T> and then collects the results of the (item: T) => 0 subscripts into a single Array<O> that commits to have the same number of items as the input Array<T> . Therefore, the first call in a subscript must be compatible with the type of the input.","title":"Subscripts"},{"location":"protocol/data-requests/radon/wrapping/","text":"Implicit Result<V> wrapping \u00b6 When the last call in a RADON script is successfully executed, its result does not progress directly to the next phase in the data request life cycle. Instead, it is first wrapped in a Result<T> with value Ok<T> , where T is the return data type of the last call in the script.","title":"Implicit `Result<V>` wrapping"},{"location":"protocol/data-requests/radon/wrapping/#implicit-resultv-wrapping","text":"When the last call in a RADON script is successfully executed, its result does not progress directly to the next phase in the data request life cycle. Instead, it is first wrapped in a Result<T> with value Ok<T> , where T is the return data type of the last call in the script.","title":"Implicit Result&lt;V&gt; wrapping"},{"location":"protocol/data-requests/radon/types/array/","text":"Array<T> type \u00b6 An Array<T> is an ordered sequence of zero, one or more values or data structures of the same type, T . Array.count() \u00b6 count () : Int ARRAY_COUNT The count operator just takes an Array<T> and returns its length as an Int . Array.every(function) \u00b6 every ( function : ( item : T ) => Boolean )) : Boolean [ ARRAY_EVERY , function ] The .every operator returns True if the result of applying a function on every each of the items in a given Array<T> is True . It returns False otherwise. The supplied (input: T): O function can be either be a valid subscript over type T or one of the predefined filtering functions . This operator can throw a runtime exception under several circumstances, including: T in the input Array<T> is Mixed Array.filter(function) \u00b6 filter ( function : ( item : T ) => Boolean ) : Array < T > [ ARRAY_FILTER , function ] This operator applies a filtering function on an Array . That is, it will apply the function on every item in the Array and drop those returning False values. The supplied (input: T): O function can be either be a valid subscript over type T or one of the predefined filtering functions . This operator can throw a runtime exception under several circumstances, including: T in the input Array<T> is Mixed Array.flatten() \u00b6 flatten ( depth : Int ) : Array < T > ARRAY_FLATTEN The flatten operator returns a new Array<T> with all the contained Array<T> concatenated into it recursively up to the supplied depth : Int . As Result<T> is equivalent to an Array<T> with zero or one item, applying flatten on an Array<Result<T>> conveniently returns an Array<T> containing only the unwrapped positive results. Example: flattening Array<Result<T>> into Array<T> [ // Array<Int> [ ARRAY_MAP , [ // Int [ INT_MULT , 2 ] // Int ] ], // Array<Result<Int>> ARRAY_FLATTEN , // Array<Int>> [ ARRAY_REDUCE , REDUCER_AVG_MEAN ] // Int ] // Result<Int> Array.get(index) \u00b6 get ( index : Int ) : T [ ARRAY_GET , index ] The get operator returns the T item at index : Int in an Array<T> . This operator can throw a runtime exception if the supplied index : Int is out of the range of the input Array<T> . Exceptions are handled as specified in the [Exception handling] section. Array.map(operator) \u00b6 map < O > ( function : ( item : T ) => O ) : Array < Result < O >> [ ARRAY_MAP , operator ] The map operator returns a new Array with the results of executing a supplied (item: T): O function on every T element in the input Array<T> , each wrapped in a Result . The supplied (input: T): O function must be a valid subscript over type T . It could happen that the supplied operator failed on some of the T values in the input Array<T> . In such case, breaking the data flow and throwing a runtime exception would be unacceptable. Instead, the map operator wraps each of the items in the returned Array into a Result . Therefore, the return type of the map operator is Array<Result<O>> , where O is the return type of the supplied (item: T): O operator. Example [ // String STRING_PARSEJSON , // Mixed [ MIXED_TOARRAY , TYPE_FLOAT ], // Array<Float> [ ARRAY_MAP , FLOAT_TRUNC ], // Array<Result<Float>> [ ARRAY_FLATMAP ], // Array<Float>, [ ARRAY_REDUCE , REDUCER_AVG_MEAN ] // Float ] // Result<Float> Array.reduce(function) \u00b6 reduce ( function : ( item : T ) => T )) : T [ ARRAY_REDUCE , function ] The reduce operator aggregates the items in the input Array<T> using a the supplied (input: T): O function and returns a single item of type T . The supplied (input: T): O function can be either a valid subscript over type T or one of the [predefined reducing functions][reducer]. This operator can throw a runtime exception under several circumstances, including: T in the input Array<T> is Mixed the reduction function is not mode and T in the input Array<T> is not Int or Float Array.some(function) \u00b6 some ( function : ( item : T ) => Boolean ) : Boolean [ ARRAY_SOME , function ] The some operator returns True if the result of applying a function on at least one of the items in a given Array<T> is True . It returns False otherwise. The supplied (item: T): Boolean function can be either one of the predefined filtering functions or a valid subscript with input type T and output type Boolean . Array.sort(mapFunction, ascending) \u00b6 sort < V > ( mapFunction : ( item : T ) => V , ascending : Boolean = True ) : Array < T > [ ARRAY_SORT , mapFunction , ascending ] The sort operator returns a new Array<T> with the very same items from the input Array<T> but ordered according to the sorting criteria defined by the supplied mapFunction: (item: T) => V and ascending : Boolean arguments. The supplied mapFunction: (item: T) => V must be a valid subscript over type T , and its V output type must be one of the value types: Boolean , Int , Float or String . This function gives the sort operator the power to sort the items in the input Array<T> not by their values but by the values resulting from applying some computation on them. Example [ // Array<Map<String, Int>> [ ARRAY_SORT , [ // Map<String, Int> [ MAP_GET , \"age\" ] // Int ], False ] // Array<Map<String, Int>> ] // Result<Array<Map<String, Int>>> Remember The \"identity\" subscript (one that returns its own input without any transformation) is expressed in RADON as an empty Array : [ ARRAY_SORT , [] ] Array.take(min, max) \u00b6 take ( min? : Int , max? : Int ) : Array < T > [ ARRAY_TAKE , min , max ] // Providing both a minimum and a maximum The take operator returns a new Array<T> with at least the min : Int first items in the input Array<T> and at most max : Int items. Take at least / Take at most / Take exactly This operator can be easily used to reproduce the \"take at least N items\" and \"take at most N items\" behaviors separately: [ ARRAY_TAKE , 5 ] // \"take at least 5 items\" [ ARRAY_TAKE , 0 , 10 ] // \"take at most 10 items\" Conversely, this will take exactly 7 item (or fail if there are not enough items): [ ARRAY_TAKE , 7 , 7 ] This operator can throw a runtime exception if the input Array<T> does not contain enough items to satisfy the minimum amount of items required by the supplied min : Int argument.","title":"Array<V>"},{"location":"protocol/data-requests/radon/types/array/#arrayt-type","text":"An Array<T> is an ordered sequence of zero, one or more values or data structures of the same type, T .","title":"Array&lt;T&gt; type"},{"location":"protocol/data-requests/radon/types/array/#arraycount","text":"count () : Int ARRAY_COUNT The count operator just takes an Array<T> and returns its length as an Int .","title":"Array.count()"},{"location":"protocol/data-requests/radon/types/array/#arrayeveryfunction","text":"every ( function : ( item : T ) => Boolean )) : Boolean [ ARRAY_EVERY , function ] The .every operator returns True if the result of applying a function on every each of the items in a given Array<T> is True . It returns False otherwise. The supplied (input: T): O function can be either be a valid subscript over type T or one of the predefined filtering functions . This operator can throw a runtime exception under several circumstances, including: T in the input Array<T> is Mixed","title":"Array.every(function)"},{"location":"protocol/data-requests/radon/types/array/#arrayfilterfunction","text":"filter ( function : ( item : T ) => Boolean ) : Array < T > [ ARRAY_FILTER , function ] This operator applies a filtering function on an Array . That is, it will apply the function on every item in the Array and drop those returning False values. The supplied (input: T): O function can be either be a valid subscript over type T or one of the predefined filtering functions . This operator can throw a runtime exception under several circumstances, including: T in the input Array<T> is Mixed","title":"Array.filter(function)"},{"location":"protocol/data-requests/radon/types/array/#arrayflatten","text":"flatten ( depth : Int ) : Array < T > ARRAY_FLATTEN The flatten operator returns a new Array<T> with all the contained Array<T> concatenated into it recursively up to the supplied depth : Int . As Result<T> is equivalent to an Array<T> with zero or one item, applying flatten on an Array<Result<T>> conveniently returns an Array<T> containing only the unwrapped positive results. Example: flattening Array<Result<T>> into Array<T> [ // Array<Int> [ ARRAY_MAP , [ // Int [ INT_MULT , 2 ] // Int ] ], // Array<Result<Int>> ARRAY_FLATTEN , // Array<Int>> [ ARRAY_REDUCE , REDUCER_AVG_MEAN ] // Int ] // Result<Int>","title":"Array.flatten()"},{"location":"protocol/data-requests/radon/types/array/#arraygetindex","text":"get ( index : Int ) : T [ ARRAY_GET , index ] The get operator returns the T item at index : Int in an Array<T> . This operator can throw a runtime exception if the supplied index : Int is out of the range of the input Array<T> . Exceptions are handled as specified in the [Exception handling] section.","title":"Array.get(index)"},{"location":"protocol/data-requests/radon/types/array/#arraymapoperator","text":"map < O > ( function : ( item : T ) => O ) : Array < Result < O >> [ ARRAY_MAP , operator ] The map operator returns a new Array with the results of executing a supplied (item: T): O function on every T element in the input Array<T> , each wrapped in a Result . The supplied (input: T): O function must be a valid subscript over type T . It could happen that the supplied operator failed on some of the T values in the input Array<T> . In such case, breaking the data flow and throwing a runtime exception would be unacceptable. Instead, the map operator wraps each of the items in the returned Array into a Result . Therefore, the return type of the map operator is Array<Result<O>> , where O is the return type of the supplied (item: T): O operator. Example [ // String STRING_PARSEJSON , // Mixed [ MIXED_TOARRAY , TYPE_FLOAT ], // Array<Float> [ ARRAY_MAP , FLOAT_TRUNC ], // Array<Result<Float>> [ ARRAY_FLATMAP ], // Array<Float>, [ ARRAY_REDUCE , REDUCER_AVG_MEAN ] // Float ] // Result<Float>","title":"Array.map(operator)"},{"location":"protocol/data-requests/radon/types/array/#arrayreducefunction","text":"reduce ( function : ( item : T ) => T )) : T [ ARRAY_REDUCE , function ] The reduce operator aggregates the items in the input Array<T> using a the supplied (input: T): O function and returns a single item of type T . The supplied (input: T): O function can be either a valid subscript over type T or one of the [predefined reducing functions][reducer]. This operator can throw a runtime exception under several circumstances, including: T in the input Array<T> is Mixed the reduction function is not mode and T in the input Array<T> is not Int or Float","title":"Array.reduce(function)"},{"location":"protocol/data-requests/radon/types/array/#arraysomefunction","text":"some ( function : ( item : T ) => Boolean ) : Boolean [ ARRAY_SOME , function ] The some operator returns True if the result of applying a function on at least one of the items in a given Array<T> is True . It returns False otherwise. The supplied (item: T): Boolean function can be either one of the predefined filtering functions or a valid subscript with input type T and output type Boolean .","title":"Array.some(function)"},{"location":"protocol/data-requests/radon/types/array/#arraysortmapfunction-ascending","text":"sort < V > ( mapFunction : ( item : T ) => V , ascending : Boolean = True ) : Array < T > [ ARRAY_SORT , mapFunction , ascending ] The sort operator returns a new Array<T> with the very same items from the input Array<T> but ordered according to the sorting criteria defined by the supplied mapFunction: (item: T) => V and ascending : Boolean arguments. The supplied mapFunction: (item: T) => V must be a valid subscript over type T , and its V output type must be one of the value types: Boolean , Int , Float or String . This function gives the sort operator the power to sort the items in the input Array<T> not by their values but by the values resulting from applying some computation on them. Example [ // Array<Map<String, Int>> [ ARRAY_SORT , [ // Map<String, Int> [ MAP_GET , \"age\" ] // Int ], False ] // Array<Map<String, Int>> ] // Result<Array<Map<String, Int>>> Remember The \"identity\" subscript (one that returns its own input without any transformation) is expressed in RADON as an empty Array : [ ARRAY_SORT , [] ]","title":"Array.sort(mapFunction, ascending)"},{"location":"protocol/data-requests/radon/types/array/#arraytakemin-max","text":"take ( min? : Int , max? : Int ) : Array < T > [ ARRAY_TAKE , min , max ] // Providing both a minimum and a maximum The take operator returns a new Array<T> with at least the min : Int first items in the input Array<T> and at most max : Int items. Take at least / Take at most / Take exactly This operator can be easily used to reproduce the \"take at least N items\" and \"take at most N items\" behaviors separately: [ ARRAY_TAKE , 5 ] // \"take at least 5 items\" [ ARRAY_TAKE , 0 , 10 ] // \"take at most 10 items\" Conversely, this will take exactly 7 item (or fail if there are not enough items): [ ARRAY_TAKE , 7 , 7 ] This operator can throw a runtime exception if the input Array<T> does not contain enough items to satisfy the minimum amount of items required by the supplied min : Int argument.","title":"Array.take(min, max)"},{"location":"protocol/data-requests/radon/types/boolean/","text":"Boolean type \u00b6 The Boolean data type can only take one of two possible values: true or false . Boolean.match(categories, default) \u00b6 match < V > ( categories : Map < Boolean , V > , default : V ) : V [ BOOLEAN_MATCH , [ /** `[key, value]` pairs **/ ] ] The match operator maps the input Boolean into different V values as defined in a Map<Boolean, V> by checking whether it matches against any of its Boolean keys. That is, it classifies the input Boolean value into separate compartments or buckets . If the input Boolean value is found as a key of categories : Map < Boolean , V > , it returns the V value associated to such key. It returns the default : V value otherwise. The V type must be one of the value types: Boolean , Int , Float or String . Example [ BOOLEAN_MATCH , [ [ True , \"Valid\" ], [ False , \"Invalid\" ] ] ] This operator will throw a runtime exception if no default value is provided and the input Boolean value is not found as a key of categories : Map < Boolean , V > . Exceptions are handled as specified in the [Exception handling] section. Boolean.neg() \u00b6 neg () : Boolean BOOLEAN_NEG The neg operator returns the negation of the input Boolean value. That is, it returns True as Boolean only if the input Boolean is False . It returns False as Boolean otherwise. Boolean.toString() \u00b6 toString () : String BOOLEAN_TOSTRING The toString operator returns a String representing the input Boolean value. That is, it returns True as String only if the input Boolean is True . It returns False as String otherwise.","title":"Boolean"},{"location":"protocol/data-requests/radon/types/boolean/#boolean-type","text":"The Boolean data type can only take one of two possible values: true or false .","title":"Boolean type"},{"location":"protocol/data-requests/radon/types/boolean/#booleanmatchcategories-default","text":"match < V > ( categories : Map < Boolean , V > , default : V ) : V [ BOOLEAN_MATCH , [ /** `[key, value]` pairs **/ ] ] The match operator maps the input Boolean into different V values as defined in a Map<Boolean, V> by checking whether it matches against any of its Boolean keys. That is, it classifies the input Boolean value into separate compartments or buckets . If the input Boolean value is found as a key of categories : Map < Boolean , V > , it returns the V value associated to such key. It returns the default : V value otherwise. The V type must be one of the value types: Boolean , Int , Float or String . Example [ BOOLEAN_MATCH , [ [ True , \"Valid\" ], [ False , \"Invalid\" ] ] ] This operator will throw a runtime exception if no default value is provided and the input Boolean value is not found as a key of categories : Map < Boolean , V > . Exceptions are handled as specified in the [Exception handling] section.","title":"Boolean.match(categories, default)"},{"location":"protocol/data-requests/radon/types/boolean/#booleanneg","text":"neg () : Boolean BOOLEAN_NEG The neg operator returns the negation of the input Boolean value. That is, it returns True as Boolean only if the input Boolean is False . It returns False as Boolean otherwise.","title":"Boolean.neg()"},{"location":"protocol/data-requests/radon/types/boolean/#booleantostring","text":"toString () : String BOOLEAN_TOSTRING The toString operator returns a String representing the input Boolean value. That is, it returns True as String only if the input Boolean is True . It returns False as String otherwise.","title":"Boolean.toString()"},{"location":"protocol/data-requests/radon/types/float/","text":"Float type \u00b6 Float.abs() \u00b6 abs () : Float FLOAT_ABS The abs operator returns the absolute value of the input Float number. That is, its distance from zero, without regard of its sign. Float.ceil() \u00b6 ceil () : Int FLOAT_CEIL The ceil operator returns the smallest Int number greater than or equal to the input Float number. Float.floor() \u00b6 floor () : Int FLOAT_FLOOR The floor operator returns the largest Int number less than or equal to the input Float number. Float.modulo(modulus) \u00b6 modulo ( modulus : Int ) : Float [ FLOAT_MODULO , modulus ] The modulo operator returns the remainder after the division of the input Float value by the modulus : Float value supplied as an argument. The resulting value always takes the same sign as the input Float value. Float.mult(factor) \u00b6 mult ( factor : Float ) : Float [ FLOAT_MULT , factor ] The mult operator returns the multiplication of the input Float value and the factor : Float value supplied as an argument. Where is the division operator? Division is not an elementary operator in RADON. It is instead achieved by composing the reciprocal ( recip ) and multiplication ( mult ) operators. This operator can throw a runtime exception if the resulting value overflows or underflows the range of the Float type. Exceptions are handled as specified in the [Exception handling] section. Float.neg() \u00b6 neg () : Float FLOAT_NEG The neg operator returns the additive inverse, opposite, sign change or negation of the input Float number. That is, the number that, when added to the input number, yields zero. Float.pow(exponent) \u00b6 pow ( exponent : Float ) : Float [ FLOAT_POW , exponent ] The pow operator returns the value of the input Float as base, exponentiated to the exponent : Float power. Where is the nth -root operator? The nth -root is not an elementary operator in RADON. It is instead achieved by composing the reciprocal ( recip ) and nth -power ( pow ) operators. This operator can throw a runtime exception if the resulting value overflows or underflows the range of the Float type. Exceptions are handled as specified in the [Exception handling] section. Float.recip() \u00b6 recip () : Float FLOAT_RECIP The recip operator returns the multiplicative inverse or reciprocal of the input Float number. That is, the number which multiplied by the input number, yields 1. This operator will throw a runtime exception if the input Float is 0 , given that the reciprocal would be infinity, which is way beyond the bounds of a Float number. Exceptions are handled as specified in the [Exception handling] section. Float.round() \u00b6 round () : Int FLOAT_ROUND The round operator returns the value of the input Float number as an Int by rounding to the nearest integer. Float.sum(addend) \u00b6 sum ( addend : Float ) : Float [ FLOAT_SUM , addend ] The sum operator returns the sum of the input Float value and the addend : Float value supplied as an argument. Where is the difference operator? Difference is not an elementary operator in RADON. It is instead achieved by composing the negation ( neg ) and summation ( sum ) operators. This operator can throw a runtime exception if the resulting value overflows or underflows the range of the Float type. Exceptions are handled as specified in the [Exception handling] section. Float.toString() \u00b6 toString ( decimals : Int ) : String [ FLOAT_TOSTRING , decimals ] The toString operator returns a String representing the input Float value using the provided base and the minimum number of fractional digits possible. The accepted bases are the same as in [ String::toInt(base) ][StringToInt]. If no base is specified, the default base will be 10 (decimal). Float.trunc() \u00b6 trunc () : Int FLOAT_TRUNC The trunc operator returns the integer part of the input Float number as an Int by removing any fractional digits.","title":"Float"},{"location":"protocol/data-requests/radon/types/float/#float-type","text":"","title":"Float type"},{"location":"protocol/data-requests/radon/types/float/#floatabs","text":"abs () : Float FLOAT_ABS The abs operator returns the absolute value of the input Float number. That is, its distance from zero, without regard of its sign.","title":"Float.abs()"},{"location":"protocol/data-requests/radon/types/float/#floatceil","text":"ceil () : Int FLOAT_CEIL The ceil operator returns the smallest Int number greater than or equal to the input Float number.","title":"Float.ceil()"},{"location":"protocol/data-requests/radon/types/float/#floatfloor","text":"floor () : Int FLOAT_FLOOR The floor operator returns the largest Int number less than or equal to the input Float number.","title":"Float.floor()"},{"location":"protocol/data-requests/radon/types/float/#floatmodulomodulus","text":"modulo ( modulus : Int ) : Float [ FLOAT_MODULO , modulus ] The modulo operator returns the remainder after the division of the input Float value by the modulus : Float value supplied as an argument. The resulting value always takes the same sign as the input Float value.","title":"Float.modulo(modulus)"},{"location":"protocol/data-requests/radon/types/float/#floatmultfactor","text":"mult ( factor : Float ) : Float [ FLOAT_MULT , factor ] The mult operator returns the multiplication of the input Float value and the factor : Float value supplied as an argument. Where is the division operator? Division is not an elementary operator in RADON. It is instead achieved by composing the reciprocal ( recip ) and multiplication ( mult ) operators. This operator can throw a runtime exception if the resulting value overflows or underflows the range of the Float type. Exceptions are handled as specified in the [Exception handling] section.","title":"Float.mult(factor)"},{"location":"protocol/data-requests/radon/types/float/#floatneg","text":"neg () : Float FLOAT_NEG The neg operator returns the additive inverse, opposite, sign change or negation of the input Float number. That is, the number that, when added to the input number, yields zero.","title":"Float.neg()"},{"location":"protocol/data-requests/radon/types/float/#floatpowexponent","text":"pow ( exponent : Float ) : Float [ FLOAT_POW , exponent ] The pow operator returns the value of the input Float as base, exponentiated to the exponent : Float power. Where is the nth -root operator? The nth -root is not an elementary operator in RADON. It is instead achieved by composing the reciprocal ( recip ) and nth -power ( pow ) operators. This operator can throw a runtime exception if the resulting value overflows or underflows the range of the Float type. Exceptions are handled as specified in the [Exception handling] section.","title":"Float.pow(exponent)"},{"location":"protocol/data-requests/radon/types/float/#floatrecip","text":"recip () : Float FLOAT_RECIP The recip operator returns the multiplicative inverse or reciprocal of the input Float number. That is, the number which multiplied by the input number, yields 1. This operator will throw a runtime exception if the input Float is 0 , given that the reciprocal would be infinity, which is way beyond the bounds of a Float number. Exceptions are handled as specified in the [Exception handling] section.","title":"Float.recip()"},{"location":"protocol/data-requests/radon/types/float/#floatround","text":"round () : Int FLOAT_ROUND The round operator returns the value of the input Float number as an Int by rounding to the nearest integer.","title":"Float.round()"},{"location":"protocol/data-requests/radon/types/float/#floatsumaddend","text":"sum ( addend : Float ) : Float [ FLOAT_SUM , addend ] The sum operator returns the sum of the input Float value and the addend : Float value supplied as an argument. Where is the difference operator? Difference is not an elementary operator in RADON. It is instead achieved by composing the negation ( neg ) and summation ( sum ) operators. This operator can throw a runtime exception if the resulting value overflows or underflows the range of the Float type. Exceptions are handled as specified in the [Exception handling] section.","title":"Float.sum(addend)"},{"location":"protocol/data-requests/radon/types/float/#floattostring","text":"toString ( decimals : Int ) : String [ FLOAT_TOSTRING , decimals ] The toString operator returns a String representing the input Float value using the provided base and the minimum number of fractional digits possible. The accepted bases are the same as in [ String::toInt(base) ][StringToInt]. If no base is specified, the default base will be 10 (decimal).","title":"Float.toString()"},{"location":"protocol/data-requests/radon/types/float/#floattrunc","text":"trunc () : Int FLOAT_TRUNC The trunc operator returns the integer part of the input Float number as an Int by removing any fractional digits.","title":"Float.trunc()"},{"location":"protocol/data-requests/radon/types/int/","text":"Int type \u00b6 Int.abs() \u00b6 abs () : Int INT_ABS The abs operator returns the absolute value of the input Int number. That is, its distance from zero, without regard of its sign. Int.match(categories, default) \u00b6 match < V > ( categories : Map < Int , V > , default ?: V ) : V [ INT_MATCH , [ /** `[key, value]` pairs **/ ] , default ] The match operator maps the input Int into different V values as defined in a Map<Int, V> by checking if it matches against any of its Int keys. That is, it classifies the input Int value into separate compartments or buckets . If the input Int value is found as a key of categories : Map < Int , V > , it returns the V value associated to such key. It returns the default : V value otherwise. Example [ INT_MATCH , [ [ 1 , \"One\" ], [ 2 , \"Two\" ], [ 3 , \"Three\" ] ], \"Other\" ] This operator will throw a runtime exception if no default value is provided and the input Int value is not found as a key of categories : Map < Int , V > . Exceptions are handled as specified in the [Exception handling] section. Int.modulo(modulus) \u00b6 modulo ( modulus : Int ) : Int [ INT_MODULO , modulus ] The modulo operator returns the remainder after the division of the input Int value by the modulus : Int value supplied as an argument. The resulting value always takes the same sign as the input Int value. Int.mult(factor) \u00b6 mult ( factor : Int ) : Int [ INT_MULT , factor ] The mult operator returns the multiplication of the input Int value and the factor : Int value supplied as an argument. Where is the division operator? Division is not an elementary operator in RADON. It is instead achieved by composing the reciprocal ( recip ) and multiplication ( mult ) operators. This operator can throw a runtime exception if the resulting value overflows or underflows the range of the Int type. Exceptions are handled as specified in the [Exception handling] section. Int.neg() \u00b6 neg () : Int INT_NEG The neg operator returns the additive inverse, opposite, sign change or negation of the input Int number. That is, the number that, when added to the input number, yields zero. Int.pow(exponent) \u00b6 pow ( exponent : Float ) : Float [ INT_POW , exponent ] The pow operator returns the value of the input Int as base, exponentiated to the exponent : Float power. Where is the nth -root operator? The nth -root is not an elementary operator in RADON. It is instead achieved by composing the reciprocal ( recip ) and nth -power ( pow ) operators. This operator can throw a runtime exception if the resulting value overflows or underflows the range of the Float type. Exceptions are handled as specified in the [Exception handling] section. Int.recip() \u00b6 recip () : Float INT_RECIP The recip operator returns the multiplicative inverse or reciprocal of the input Int number. That is, the number which multiplied by the input number, yields 1. This operator will throw a runtime exception if the input Int is 0 , given that the reciprocal would be infinity, which is way beyond the bounds of a Float number. Exceptions are handled as specified in the [Exception handling] section. Int.sum(addend) \u00b6 sum ( addend : Int ) : Int [ INT_SUM , addend ] The sum operator returns the sum of the input Int value and the addend : Int value supplied as an argument. Where is the difference operator? Difference is not an elementary operator in RADON. It is instead achieved by composing the negation ( neg ) and summation ( sum ) operators. This operator can throw a runtime exception if the resulting value overflows or underflows the range of the Int type. Exceptions are handled as specified in the [Exception handling] section. Int.toFloat() \u00b6 toFloat () : Float INT_TOFLOAT The toFloat operator returns the value of the input Int as a floating point number. Int.toString() \u00b6 toString ( base? : Int ) : String [ INT_TOSTRING , base ] The toString operator returns a String representing the input Int value using the provided base. The accepted bases are the same as in [ String::toInt(base) ][StringToInt]. If no base is specified, the default base will be 10 (decimal).","title":"Int"},{"location":"protocol/data-requests/radon/types/int/#int-type","text":"","title":"Int type"},{"location":"protocol/data-requests/radon/types/int/#intabs","text":"abs () : Int INT_ABS The abs operator returns the absolute value of the input Int number. That is, its distance from zero, without regard of its sign.","title":"Int.abs()"},{"location":"protocol/data-requests/radon/types/int/#intmatchcategories-default","text":"match < V > ( categories : Map < Int , V > , default ?: V ) : V [ INT_MATCH , [ /** `[key, value]` pairs **/ ] , default ] The match operator maps the input Int into different V values as defined in a Map<Int, V> by checking if it matches against any of its Int keys. That is, it classifies the input Int value into separate compartments or buckets . If the input Int value is found as a key of categories : Map < Int , V > , it returns the V value associated to such key. It returns the default : V value otherwise. Example [ INT_MATCH , [ [ 1 , \"One\" ], [ 2 , \"Two\" ], [ 3 , \"Three\" ] ], \"Other\" ] This operator will throw a runtime exception if no default value is provided and the input Int value is not found as a key of categories : Map < Int , V > . Exceptions are handled as specified in the [Exception handling] section.","title":"Int.match(categories, default)"},{"location":"protocol/data-requests/radon/types/int/#intmodulomodulus","text":"modulo ( modulus : Int ) : Int [ INT_MODULO , modulus ] The modulo operator returns the remainder after the division of the input Int value by the modulus : Int value supplied as an argument. The resulting value always takes the same sign as the input Int value.","title":"Int.modulo(modulus)"},{"location":"protocol/data-requests/radon/types/int/#intmultfactor","text":"mult ( factor : Int ) : Int [ INT_MULT , factor ] The mult operator returns the multiplication of the input Int value and the factor : Int value supplied as an argument. Where is the division operator? Division is not an elementary operator in RADON. It is instead achieved by composing the reciprocal ( recip ) and multiplication ( mult ) operators. This operator can throw a runtime exception if the resulting value overflows or underflows the range of the Int type. Exceptions are handled as specified in the [Exception handling] section.","title":"Int.mult(factor)"},{"location":"protocol/data-requests/radon/types/int/#intneg","text":"neg () : Int INT_NEG The neg operator returns the additive inverse, opposite, sign change or negation of the input Int number. That is, the number that, when added to the input number, yields zero.","title":"Int.neg()"},{"location":"protocol/data-requests/radon/types/int/#intpowexponent","text":"pow ( exponent : Float ) : Float [ INT_POW , exponent ] The pow operator returns the value of the input Int as base, exponentiated to the exponent : Float power. Where is the nth -root operator? The nth -root is not an elementary operator in RADON. It is instead achieved by composing the reciprocal ( recip ) and nth -power ( pow ) operators. This operator can throw a runtime exception if the resulting value overflows or underflows the range of the Float type. Exceptions are handled as specified in the [Exception handling] section.","title":"Int.pow(exponent)"},{"location":"protocol/data-requests/radon/types/int/#intrecip","text":"recip () : Float INT_RECIP The recip operator returns the multiplicative inverse or reciprocal of the input Int number. That is, the number which multiplied by the input number, yields 1. This operator will throw a runtime exception if the input Int is 0 , given that the reciprocal would be infinity, which is way beyond the bounds of a Float number. Exceptions are handled as specified in the [Exception handling] section.","title":"Int.recip()"},{"location":"protocol/data-requests/radon/types/int/#intsumaddend","text":"sum ( addend : Int ) : Int [ INT_SUM , addend ] The sum operator returns the sum of the input Int value and the addend : Int value supplied as an argument. Where is the difference operator? Difference is not an elementary operator in RADON. It is instead achieved by composing the negation ( neg ) and summation ( sum ) operators. This operator can throw a runtime exception if the resulting value overflows or underflows the range of the Int type. Exceptions are handled as specified in the [Exception handling] section.","title":"Int.sum(addend)"},{"location":"protocol/data-requests/radon/types/int/#inttofloat","text":"toFloat () : Float INT_TOFLOAT The toFloat operator returns the value of the input Int as a floating point number.","title":"Int.toFloat()"},{"location":"protocol/data-requests/radon/types/int/#inttostring","text":"toString ( base? : Int ) : String [ INT_TOSTRING , base ] The toString operator returns a String representing the input Int value using the provided base. The accepted bases are the same as in [ String::toInt(base) ][StringToInt]. If no base is specified, the default base will be 10 (decimal).","title":"Int.toString()"},{"location":"protocol/data-requests/radon/types/map/","text":"Map<K, T> type \u00b6 Map.entries() \u00b6 entries () : Array < Array < Mixed >> MAP_ENTRIES The entries operator returns an Array<Array<Mixed>> containing the keys and values from the input Map<K, T> as [ key, value ]: Array<Mixed> pairs. Map.get(key) \u00b6 get ( key : K ) : T [ MAP_GET , key ] The get operator returns the T value or structure associated to the key : K from a Map<K, T> . This operator can throw a runtime exception if the supplied key : K cannot be found in the input Map<K, T> . Exceptions are handled as specified in the [Exception handling] section. Map.keys() \u00b6 keys () : Array < K > MAP_KEYS The keys operator returns an Array<K> containing the keys of the input Map<K, T> . Map.values() \u00b6 values () : Array < T > MAP_VALUES The values operator returns an Array<T> containing the values of the input Map<K, T> .","title":"Map<V>"},{"location":"protocol/data-requests/radon/types/map/#mapk-t-type","text":"","title":"Map&lt;K, T&gt; type"},{"location":"protocol/data-requests/radon/types/map/#mapentries","text":"entries () : Array < Array < Mixed >> MAP_ENTRIES The entries operator returns an Array<Array<Mixed>> containing the keys and values from the input Map<K, T> as [ key, value ]: Array<Mixed> pairs.","title":"Map.entries()"},{"location":"protocol/data-requests/radon/types/map/#mapgetkey","text":"get ( key : K ) : T [ MAP_GET , key ] The get operator returns the T value or structure associated to the key : K from a Map<K, T> . This operator can throw a runtime exception if the supplied key : K cannot be found in the input Map<K, T> . Exceptions are handled as specified in the [Exception handling] section.","title":"Map.get(key)"},{"location":"protocol/data-requests/radon/types/map/#mapkeys","text":"keys () : Array < K > MAP_KEYS The keys operator returns an Array<K> containing the keys of the input Map<K, T> .","title":"Map.keys()"},{"location":"protocol/data-requests/radon/types/map/#mapvalues","text":"values () : Array < T > MAP_VALUES The values operator returns an Array<T> containing the values of the input Map<K, T> .","title":"Map.values()"},{"location":"protocol/data-requests/radon/types/mixed/","text":"Mixed type \u00b6 The Mixed type represents a value or structure whose type is undecided and cannot be automatically inferred by the interpreter. The operators available for this type assist the interpreter to handle Mixed values and structures in a deterministic way so that it can be safely casted to other, more useful types. Mixed.toArray(type) \u00b6 toArray < T > ( type? : String ) : Array < T > [ MIXED_TOARRAY , type ] The toArray operator tries to cast the input Mixed to an Array<T> structure, where T is any of the RADON types, supplied by name as the type : String argument. If no type : String is supplied, the output type will be Array<Mixed> by default. This operator will throw a runtime exception if the input Mixed cannot be casted to a valid Boolean value. Exceptions are handled as specified in the [Exception handling] section. Mixed.toBoolean() \u00b6 toBoolean () : Boolean MIXED_TOBOOLEAN The toBoolean operator tries to cast the input Mixed to a Boolean value. That is, it returns True if the input is True as either Boolean or String ; or False as Boolean if the input Mixed is False as either Boolean or String . This operator will throw a runtime exception if the input Mixed cannot be casted to a valid Boolean value. Exceptions are handled as specified in the [Exception handling] section. Mixed.toFloat() \u00b6 toFloat () : Float MIXED_TOFLOAT The toFloat operator tries to cast the input Mixed to a Float value. This operator will throw a runtime exception if the input Mixed cannot be casted to a valid Float value for the specified base or if the value overflows or underflows the range of the Float type. Exceptions are handled as specified in the [Exception handling] section. Mixed.toInt() \u00b6 toInt ( base? : Int ) : Int [ MIXED_TOINT , base ] The toInt operator parses the input Mixed as an integer of the specified base. The accepted bases are the same as in [ String::toInt(base) ][StringToInt]. If no base is specified, the default base will be 10 (decimal). This operator will throw a runtime exception if: The input Mixed cannot be casted to a valid Int value for the specified base The value overflows or underflows the range of the Int type. Exceptions are handled as specified in the [Exception handling] section. Mixed.toMap(keyType, valueType) \u00b6 toMap < K , T > ( keyType? : String , valueType? : String ) : Map < K , T > [ MIXED_TOMAP , keyType , valueType ] The toArray operator tries to cast the input Mixed to a Map<K, T> structure, where K is only one of the RADON [value types] , supplied by name as the keyType : String argument; and T is any of the RADON types, supplied by name as the valueType : String argument. If no keyType : String is supplied, it will be assumed to be String by default. If no valueType : String is supplied, it will be assumed to be Mixed by default. This operator will throw a runtime exception if the input Mixed cannot be casted to a valid Map<K, T> value. Exceptions are handled as specified in the [Exception handling] section.","title":"Mixed"},{"location":"protocol/data-requests/radon/types/mixed/#mixed-type","text":"The Mixed type represents a value or structure whose type is undecided and cannot be automatically inferred by the interpreter. The operators available for this type assist the interpreter to handle Mixed values and structures in a deterministic way so that it can be safely casted to other, more useful types.","title":"Mixed type"},{"location":"protocol/data-requests/radon/types/mixed/#mixedtoarraytype","text":"toArray < T > ( type? : String ) : Array < T > [ MIXED_TOARRAY , type ] The toArray operator tries to cast the input Mixed to an Array<T> structure, where T is any of the RADON types, supplied by name as the type : String argument. If no type : String is supplied, the output type will be Array<Mixed> by default. This operator will throw a runtime exception if the input Mixed cannot be casted to a valid Boolean value. Exceptions are handled as specified in the [Exception handling] section.","title":"Mixed.toArray(type)"},{"location":"protocol/data-requests/radon/types/mixed/#mixedtoboolean","text":"toBoolean () : Boolean MIXED_TOBOOLEAN The toBoolean operator tries to cast the input Mixed to a Boolean value. That is, it returns True if the input is True as either Boolean or String ; or False as Boolean if the input Mixed is False as either Boolean or String . This operator will throw a runtime exception if the input Mixed cannot be casted to a valid Boolean value. Exceptions are handled as specified in the [Exception handling] section.","title":"Mixed.toBoolean()"},{"location":"protocol/data-requests/radon/types/mixed/#mixedtofloat","text":"toFloat () : Float MIXED_TOFLOAT The toFloat operator tries to cast the input Mixed to a Float value. This operator will throw a runtime exception if the input Mixed cannot be casted to a valid Float value for the specified base or if the value overflows or underflows the range of the Float type. Exceptions are handled as specified in the [Exception handling] section.","title":"Mixed.toFloat()"},{"location":"protocol/data-requests/radon/types/mixed/#mixedtoint","text":"toInt ( base? : Int ) : Int [ MIXED_TOINT , base ] The toInt operator parses the input Mixed as an integer of the specified base. The accepted bases are the same as in [ String::toInt(base) ][StringToInt]. If no base is specified, the default base will be 10 (decimal). This operator will throw a runtime exception if: The input Mixed cannot be casted to a valid Int value for the specified base The value overflows or underflows the range of the Int type. Exceptions are handled as specified in the [Exception handling] section.","title":"Mixed.toInt()"},{"location":"protocol/data-requests/radon/types/mixed/#mixedtomapkeytype-valuetype","text":"toMap < K , T > ( keyType? : String , valueType? : String ) : Map < K , T > [ MIXED_TOMAP , keyType , valueType ] The toArray operator tries to cast the input Mixed to a Map<K, T> structure, where K is only one of the RADON [value types] , supplied by name as the keyType : String argument; and T is any of the RADON types, supplied by name as the valueType : String argument. If no keyType : String is supplied, it will be assumed to be String by default. If no valueType : String is supplied, it will be assumed to be Mixed by default. This operator will throw a runtime exception if the input Mixed cannot be casted to a valid Map<K, T> value. Exceptions are handled as specified in the [Exception handling] section.","title":"Mixed.toMap(keyType, valueType)"},{"location":"protocol/data-requests/radon/types/null/","text":"Null type \u00b6 Null has no operators.","title":"Null"},{"location":"protocol/data-requests/radon/types/null/#null-type","text":"Null has no operators.","title":"Null type"},{"location":"protocol/data-requests/radon/types/overview/","text":"RADON data types \u00b6 The basic data types (also called value types ) existing in RADON are modelled to resemble those of most typed programming languages: Boolean Int Float String Additionaly, there exist six complex data types or structure types : Array<T> Map<K, T> Mixed Null Result<T> Each of these nine types and their available operators are explained below. Reading data types documentation Operators for each of the data types in this documentation are specified as: // TypeScript-alike function signature nameOfTheMethod ( argument : TypeOfArgument ) : ReturnTypeOfMethod // Actual usage in RADON TYPE_OPERATORNAME // Operators without arguments [ TYPE_OPERATORNAME , argument ] // Operators with arguments Constants All across this documentation, unquoted uppercase names like STRING_PARSEJSON identify different operators and constants that equate to a single byte when encoded. A list of constants can be found in the Contants section .","title":"Overview"},{"location":"protocol/data-requests/radon/types/overview/#radon-data-types","text":"The basic data types (also called value types ) existing in RADON are modelled to resemble those of most typed programming languages: Boolean Int Float String Additionaly, there exist six complex data types or structure types : Array<T> Map<K, T> Mixed Null Result<T> Each of these nine types and their available operators are explained below. Reading data types documentation Operators for each of the data types in this documentation are specified as: // TypeScript-alike function signature nameOfTheMethod ( argument : TypeOfArgument ) : ReturnTypeOfMethod // Actual usage in RADON TYPE_OPERATORNAME // Operators without arguments [ TYPE_OPERATORNAME , argument ] // Operators with arguments Constants All across this documentation, unquoted uppercase names like STRING_PARSEJSON identify different operators and constants that equate to a single byte when encoded. A list of constants can be found in the Contants section .","title":"RADON data types"},{"location":"protocol/data-requests/radon/types/result/","text":"Result<T> type \u00b6 Result<T> is one of the RADON complex data types. It can be thought as an Array<T> that can only contain zero or one item of type T . In that sense, it is somehow similar to the Option<T> type found in other programming languages. Result.get() \u00b6 get < T > () : T RESULT_GET The get operator unwraps the input Result<T> . That is, it returns its contained value assuming the Result<T> is positive ( Ok<T> ). This operator can throw a runtime exception if the input Result<T> is not positive ( Ok<T> ) but negative ( Err ). Exceptions are handled as specified in the [Exception handling] section. Result.getOr() \u00b6 getOr < T > ( default : T ) : T RESULT_GETOR The getOr operator returns the T value enclosed in the input Result<T> if it is positive ( Ok<T> ). It returns the supplied default : T value otherwise. Result.isOk() \u00b6 isOk () : Boolean RESULT_ISOK The isOk operator returns True as Boolean if the input Result<T> is positive ( Ok<T> ). It returns False as Boolean otherwise. Checking if a Result is negative ( Err ) is not an elementary operator in RADON. It is instead achieved by composing the isOk and negation ( neg ) operators.","title":"Result<V>"},{"location":"protocol/data-requests/radon/types/result/#resultt-type","text":"Result<T> is one of the RADON complex data types. It can be thought as an Array<T> that can only contain zero or one item of type T . In that sense, it is somehow similar to the Option<T> type found in other programming languages.","title":"Result&lt;T&gt; type"},{"location":"protocol/data-requests/radon/types/result/#resultget","text":"get < T > () : T RESULT_GET The get operator unwraps the input Result<T> . That is, it returns its contained value assuming the Result<T> is positive ( Ok<T> ). This operator can throw a runtime exception if the input Result<T> is not positive ( Ok<T> ) but negative ( Err ). Exceptions are handled as specified in the [Exception handling] section.","title":"Result.get()"},{"location":"protocol/data-requests/radon/types/result/#resultgetor","text":"getOr < T > ( default : T ) : T RESULT_GETOR The getOr operator returns the T value enclosed in the input Result<T> if it is positive ( Ok<T> ). It returns the supplied default : T value otherwise.","title":"Result.getOr()"},{"location":"protocol/data-requests/radon/types/result/#resultisok","text":"isOk () : Boolean RESULT_ISOK The isOk operator returns True as Boolean if the input Result<T> is positive ( Ok<T> ). It returns False as Boolean otherwise. Checking if a Result is negative ( Err ) is not an elementary operator in RADON. It is instead achieved by composing the isOk and negation ( neg ) operators.","title":"Result.isOk()"},{"location":"protocol/data-requests/radon/types/string/","text":"String type \u00b6 String.hash(function) \u00b6 hash ( function : String ) : String [ STRING_HASH , function ] Applies a hash function on the input String and returns its digest as an hexadecimal string. The available hash functions are listed in the Predefined functions section . String.length() \u00b6 length () : Int STRING_LENGTH The length operator returns the number of UTF-8 code units in the input String . String.match(categories, default) \u00b6 match < T > ( categories : Map < String , T > , default ?: T ) : T [ STRING_CATEGORIZE , [ /** `[key, value]` pairs **/ ], default ] The match operator maps the input String into different T values as defined in a Map<String, T> by checking if it matches against any of its String keys. That is, it classifies the input String value into separate compartments or buckets . If the input String value is found as a key of categories : Map < String , T > , it returns the T value associated to such key. It returns the default : T value otherwise. Example [ STRING_CATEGORIZE , [ [ \"rainy\" , 0 ], [ \"stormy\" , 0 ], [ \"sunny\" , 1 ] ], 2 ] This operator will throw a runtime exception if no default value is provided and the input String value is not found as a key of categories : Map < String , T > . Exceptions are handled as specified in the [Exception handling] section. String.parseJSON() \u00b6 parseJSON () : Mixed STRING_PARSEJSON Parses the input String into a Map<String, Mixed> assuming it is a correctly formed JSON document. This operator can throw a runtime exception if: The input String is not a well-formed JSON document. The type of some value in the document cannot be inferred. Exceptions are handled as specified in the [Exception handling] section. String.parseXML() \u00b6 parseXML () : Map < String , Mixed > STRING_PARSEXML Parses the input String into a Map<String, Mixed> assuming it is a correctly formed XML document. This operator can throw a runtime exception if: The input String is not a well-formed XML document. The type of some value in the document cannot be inferred. Exceptions are handled as specified in the [Exception handling] section. String.toBoolean() \u00b6 toBoolean () : Boolean STRING_TOBOOLEAN The toBoolean operator parses the input String as a Boolean value. That is, it returns True as Boolean if the input String is True ; or False as Boolean if the input String is False . This operator will throw a runtime exception if the input String is not a valid Boolean value. Exceptions are handled as specified in the [Exception handling] section. String.toFloat() \u00b6 toFloat () : Float STRING_TOFLOAT The toFloat operator parses the input String as a floating point number. This operator will throw a runtime exception if: The input String is not a valid Float value for the specified base. The value overflows or underflows the range of the Float type. Exceptions are handled as specified in the [Exception handling] section. String.toInt() \u00b6 toInt ( base? : Int ) : Int [ STRING_TOINT , base ] The toInt operator parses the input String as an integer of the specified base. The accepted bases are: Base Name Example 2 Binary 1011111011101111 8 Octal 137357 10 Decimal 48879 16 Hexadecimal BEEF 32 Base32 X3XQ 64 Base64 vu8 If no base is specified, the default base will be 10 (decimal). This operator will throw a runtime exception if: The input String is not a valid Int value for the specified base. The value overflows or underflows the range of the Int type. Exceptions are handled as specified in the [Exception handling] section. String.toLowerCase() \u00b6 toLowerCase () : String STRING_TOLOWERCASE Returns the input String value converted to uppercase. String.toUpperCase() \u00b6 toUpperCase () : String STRING_TOUPPERCASE Returns the input String value converted to lowercase.","title":"String"},{"location":"protocol/data-requests/radon/types/string/#string-type","text":"","title":"String type"},{"location":"protocol/data-requests/radon/types/string/#stringhashfunction","text":"hash ( function : String ) : String [ STRING_HASH , function ] Applies a hash function on the input String and returns its digest as an hexadecimal string. The available hash functions are listed in the Predefined functions section .","title":"String.hash(function)"},{"location":"protocol/data-requests/radon/types/string/#stringlength","text":"length () : Int STRING_LENGTH The length operator returns the number of UTF-8 code units in the input String .","title":"String.length()"},{"location":"protocol/data-requests/radon/types/string/#stringmatchcategories-default","text":"match < T > ( categories : Map < String , T > , default ?: T ) : T [ STRING_CATEGORIZE , [ /** `[key, value]` pairs **/ ], default ] The match operator maps the input String into different T values as defined in a Map<String, T> by checking if it matches against any of its String keys. That is, it classifies the input String value into separate compartments or buckets . If the input String value is found as a key of categories : Map < String , T > , it returns the T value associated to such key. It returns the default : T value otherwise. Example [ STRING_CATEGORIZE , [ [ \"rainy\" , 0 ], [ \"stormy\" , 0 ], [ \"sunny\" , 1 ] ], 2 ] This operator will throw a runtime exception if no default value is provided and the input String value is not found as a key of categories : Map < String , T > . Exceptions are handled as specified in the [Exception handling] section.","title":"String.match(categories, default)"},{"location":"protocol/data-requests/radon/types/string/#stringparsejson","text":"parseJSON () : Mixed STRING_PARSEJSON Parses the input String into a Map<String, Mixed> assuming it is a correctly formed JSON document. This operator can throw a runtime exception if: The input String is not a well-formed JSON document. The type of some value in the document cannot be inferred. Exceptions are handled as specified in the [Exception handling] section.","title":"String.parseJSON()"},{"location":"protocol/data-requests/radon/types/string/#stringparsexml","text":"parseXML () : Map < String , Mixed > STRING_PARSEXML Parses the input String into a Map<String, Mixed> assuming it is a correctly formed XML document. This operator can throw a runtime exception if: The input String is not a well-formed XML document. The type of some value in the document cannot be inferred. Exceptions are handled as specified in the [Exception handling] section.","title":"String.parseXML()"},{"location":"protocol/data-requests/radon/types/string/#stringtoboolean","text":"toBoolean () : Boolean STRING_TOBOOLEAN The toBoolean operator parses the input String as a Boolean value. That is, it returns True as Boolean if the input String is True ; or False as Boolean if the input String is False . This operator will throw a runtime exception if the input String is not a valid Boolean value. Exceptions are handled as specified in the [Exception handling] section.","title":"String.toBoolean()"},{"location":"protocol/data-requests/radon/types/string/#stringtofloat","text":"toFloat () : Float STRING_TOFLOAT The toFloat operator parses the input String as a floating point number. This operator will throw a runtime exception if: The input String is not a valid Float value for the specified base. The value overflows or underflows the range of the Float type. Exceptions are handled as specified in the [Exception handling] section.","title":"String.toFloat()"},{"location":"protocol/data-requests/radon/types/string/#stringtoint","text":"toInt ( base? : Int ) : Int [ STRING_TOINT , base ] The toInt operator parses the input String as an integer of the specified base. The accepted bases are: Base Name Example 2 Binary 1011111011101111 8 Octal 137357 10 Decimal 48879 16 Hexadecimal BEEF 32 Base32 X3XQ 64 Base64 vu8 If no base is specified, the default base will be 10 (decimal). This operator will throw a runtime exception if: The input String is not a valid Int value for the specified base. The value overflows or underflows the range of the Int type. Exceptions are handled as specified in the [Exception handling] section.","title":"String.toInt()"},{"location":"protocol/data-requests/radon/types/string/#stringtolowercase","text":"toLowerCase () : String STRING_TOLOWERCASE Returns the input String value converted to uppercase.","title":"String.toLowerCase()"},{"location":"protocol/data-requests/radon/types/string/#stringtouppercase","text":"toUpperCase () : String STRING_TOUPPERCASE Returns the input String value converted to lowercase.","title":"String.toUpperCase()"}]}